<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>两点直线解析式</title>
  <style>
    .label {
      font-family: Arial;
      font-size: 14px;
      user-select: none;
    }
    /* 添加容器样式以确保滚轮事件正常工作 */
    #container {
      width: 900px;
      height: 750px;
      border: 1px solid #ccc;
      overflow: hidden;
      margin: 0 auto; /* 居中显示容器 */
      position: relative;
      /* 移除默认的 grab 光标 */
      /* cursor: grab; */
    }
    #container.grabbing {
      cursor: grabbing; /* 拖动时的光标样式 */
    }
    /* 向量信息显示样式 */
    #vectorInfo {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
    /* 解析式显示样式 */
    #lineEquation {
      margin-top: 10px;
      font-weight: bold;
    }
    /* 法向量样式 */
    .normalVector {
      stroke: orange;
      stroke-width: 2;
      marker-end: url(#arrowhead);
    }
    /* 定义箭头 */
    marker#arrowhead {
      markerWidth: 10;
      markerHeight: 7;
      refX: 10; /* 调整 refX 为箭头宽度 */
      refY: 3.5;
      orient: auto;
    }
  </style>
</head>
<body>
  <div id="container">
    <svg width="1200" height="900" id="coordinateSystem">
      <!-- 定义箭头标记 -->
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                refX="10" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="orange" />
        </marker>
      </defs>
      <g id="grid" transform="translate(150,450)">
        <g id="gridLines"></g>
        
        <!-- 原点标记 -->
        <text x="10" y="20" class="label">O(0,0)</text>
        
        <!-- 可移动的点 -->
        <g id="points">
          <circle id="pointA" cx="160" cy="-40" r="9" fill="red" style="cursor: pointer"/>
          <text id="pointAText" x="170" y="-30" class="label">A</text>
          
          <circle id="pointB" cx="80" cy="-120" r="9" fill="blue" style="cursor: pointer"/>
          <text id="pointBText" x="90" y="-110" class="label">B</text>
        </g>

        <!-- 直线AB -->
        <g id="lineAB">
          <line id="lineVector" x1="160" y1="-40" x2="80" y2="-120" stroke="green" stroke-width="2"/>
        </g>

        <!-- 法向量 -->
        <g id="normalVector">
          <line id="normalLine" x1="0" y1="0" x2="0" y2="0" class="normalVector"/>
          <text id="normalText" x="0" y="0" class="label" fill="orange">法向量 (A, B)</text>
        </g>
      </g>
    </svg>

    <!-- 向量信息显示 -->
    <div id="vectorInfo">
      <div id="lineEquation">
        直线解析式: <span id="equation">正在计算...</span>
      </div>
    </div>
  </div>
  
  <script>
    const svg = document.getElementById('coordinateSystem');
    const grid = document.getElementById('gridLines');
    const pointA = document.getElementById('pointA');
    const pointB = document.getElementById('pointB');
    const pointAText = document.getElementById('pointAText');
    const pointBText = document.getElementById('pointBText');
    const lineVector = document.getElementById('lineVector');
    const equationText = document.getElementById('equation');
    const normalLine = document.getElementById('normalLine');
    const normalText = document.getElementById('normalText');
    const container = document.getElementById('container');
    const gridGroup = document.getElementById('grid');

    const config = {
      scale: 35,          // 每个单位的像素数
      minScale: 10,       // 最小缩放比例
      maxScale: 100,      // 最大缩放比例
      gridColor: "#ddd",
      axisColor: "black",
      pointRadius: 9,
      pointStyles: {
        A: { fill: "red" },
        B: { fill: "blue" }
      }
    };
    
    /**
     * 计算最大公约数（Euclidean算法）
     */
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (b === 0) return a;
      return gcd(b, a % b);
    }

    function gcdMultiple(...numbers) {
      return numbers.reduce((acc, num) => {
        if (num === 0) return acc;
        return gcd(acc, num);
      }, 0);
    }

    /**
     * 动态计算网格范围
     * 根据当前的平移和缩放，计算需要绘制的网格线数量
     */
    function calculateGridRange() {
      // 根据平移和缩放计算可见范围
      const visibleLeft = -currentTranslate.x / config.scale;
      const visibleRight = (svg.clientWidth - currentTranslate.x) / config.scale;
      const visibleTop = currentTranslate.y / config.scale;
      const visibleBottom = (-svg.clientHeight + currentTranslate.y) / config.scale;
      
      config.gridRangeX = Math.ceil(Math.max(Math.abs(visibleLeft), Math.abs(visibleRight)));
      config.gridRangeY = Math.ceil(Math.max(Math.abs(visibleTop), Math.abs(visibleBottom)));
    }
    
    /**
     * 绘制网格和坐标轴
     */
    function drawGrid() {
      grid.innerHTML = '';
      
      // 绘制水平网格线和Y轴标签
      for (let i = -config.gridRangeY; i <= config.gridRangeY; i++) {
        const pos = i * config.scale;
        
        if (i !== 0) {
          // 水平网格线
          const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
          hLine.setAttribute("x1", -config.gridRangeX * config.scale);
          hLine.setAttribute("y1", pos);
          hLine.setAttribute("x2", config.gridRangeX * config.scale);
          hLine.setAttribute("y2", pos);
          hLine.setAttribute("stroke", config.gridColor);
          hLine.setAttribute("stroke-width", "1");
          grid.appendChild(hLine);

          // Y轴标签
          const yLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
          yLabel.setAttribute("x", 5);
          yLabel.setAttribute("y", -pos + 5);
          yLabel.setAttribute("class", "label");
          yLabel.textContent = i;
          grid.appendChild(yLabel);
        }
      }
      
      // 绘制垂直网格线和X轴标签
      for (let i = -config.gridRangeX; i <= config.gridRangeX; i++) {
        const pos = i * config.scale;
        
        if (i !== 0) {
          // 垂直网格线
          const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
          vLine.setAttribute("x1", pos);
          vLine.setAttribute("y1", -config.gridRangeY * config.scale);
          vLine.setAttribute("x2", pos);
          vLine.setAttribute("y2", config.gridRangeY * config.scale);
          vLine.setAttribute("stroke", config.gridColor);
          vLine.setAttribute("stroke-width", "1");
          grid.appendChild(vLine);

          // X轴标签
          const xLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
          xLabel.setAttribute("x", pos);
          xLabel.setAttribute("y", 20);
          xLabel.setAttribute("class", "label");
          xLabel.setAttribute("text-anchor", "middle");
          xLabel.textContent = i;
          grid.appendChild(xLabel);
        }
      }
      
      // 绘制坐标轴
      const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
      xAxis.setAttribute("x1", -config.gridRangeX * config.scale);
      xAxis.setAttribute("y1", 0);
      xAxis.setAttribute("x2", config.gridRangeX * config.scale);
      xAxis.setAttribute("y2", 0);
      xAxis.setAttribute("stroke", config.axisColor);
      xAxis.setAttribute("stroke-width", "2");
      grid.appendChild(xAxis);
    
      const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
      yAxis.setAttribute("x1", 0);
      yAxis.setAttribute("y1", -config.gridRangeY * config.scale);
      yAxis.setAttribute("x2", 0);
      yAxis.setAttribute("y2", config.gridRangeY * config.scale);
      yAxis.setAttribute("stroke", config.axisColor);
      yAxis.setAttribute("stroke-width", "2");
      grid.appendChild(yAxis);
    }
    
    /**
     * 更新点的坐标显示
     */
    function updatePointLabel(point, text) {
      const cx = parseFloat(point.getAttribute('cx'));
      const cy = parseFloat(point.getAttribute('cy'));
      const grid_x = (cx / config.scale).toFixed(2);
      const grid_y = (-cy / config.scale).toFixed(2);
      
      if (point.id !== 'normalLine' && point.id !== 'normalText') { // 排除法向量相关元素
        text.textContent = `${point.id.slice(-1)}(${grid_x}, ${grid_y})`;
        text.setAttribute('x', cx + 10);
        text.setAttribute('y', cy + 10);
      }
    }
    
    /**
     * 更新所有点的位置和标签
     */
    function updateAllPoints() {
      // 更新点A
      updatePointLabel(pointA, pointAText);
      
      // 更新点B
      updatePointLabel(pointB, pointBText);
      
      // 更新直线AB的位置
      updateLine();
    }
    
    /**
     * 吸附所有点到最近的网格点
     */
    function snapToGrid() {
      [pointA, pointB].forEach(point => {
        const roundedX = Math.round(parseFloat(point.getAttribute('cx')) / config.scale) * config.scale;
        const roundedY = Math.round(parseFloat(point.getAttribute('cy')) / config.scale) * config.scale;
        point.setAttribute('cx', roundedX);
        point.setAttribute('cy', roundedY);
      });
      updateAllPoints();
    }

    /**
     * 更新直线 AB 的位置和解析式
     */
    function updateLine() {
      const ax = parseFloat(pointA.getAttribute('cx'));
      const ay = parseFloat(pointA.getAttribute('cy'));
      const bx = parseFloat(pointB.getAttribute('cx'));
      const by = parseFloat(pointB.getAttribute('cy'));

      // 转换为网格单位
      const grid_ax = ax / config.scale;
      const grid_ay = -ay / config.scale;
      const grid_bx = bx / config.scale;
      const grid_by = -by / config.scale;

      // 计算直线 AB 的解析式: (ya - yb)x + (xb - xa)y + (yb*xa - ya*xb) = 0
      let A_coef = grid_ay - grid_by;
      let B_coef = grid_bx - grid_ax;
      let C_coef = grid_by * grid_ax - grid_ay * grid_bx;

      // 这里不再做 gcd 化简，直接保留浮点数
      // 为了显示美观，可以做一下小数截断:
      function toFloatStr(num) {
        return parseFloat(num.toFixed(2)); // 保留 2 位小数，可自行调整
      }

      A_coef = toFloatStr(A_coef);
      B_coef = toFloatStr(B_coef);
      C_coef = toFloatStr(C_coef);

      // 如果想保持 A 为正，可以做:
      if (A_coef < 0) {
        A_coef = -A_coef;
        B_coef = -B_coef;
        C_coef = -C_coef;
      }

      // 拼接成字符串
      // 注意要处理正负号
      function formatTerm(coef, varName) {
        // 0 不输出
        if (coef === 0) return '';
        // 系数为 1 或 -1 的特殊输出
        let signStr = (coef >= 0) ? '+' : '-';
        let absVal = Math.abs(coef);
        
        // 如果 absVal === 1，则只输出 varName
        if (absVal === 1) {
          return (varName) 
            ? `${signStr} ${varName}` 
            : `${signStr} 1`; // 常数项时没变量
        } else {
          return (varName)
            ? `${signStr} ${absVal}${varName}`
            : `${signStr} ${absVal}`;
        }
      }

      let eqStr = '';
      // 处理 A_coef * x
      if (A_coef !== 0) {
        // 第一个项单独处理正负号
        eqStr += (A_coef > 0) 
          ? (A_coef === 1 ? 'x' : `${A_coef}x`)
          : (A_coef === -1 ? '- x' : `${A_coef}x`);
      }

      // 处理 B_coef * y
      if (B_coef !== 0) {
        if (A_coef === 0) {
          // 如果 A=0，那 B 可能是第一个项
          if (B_coef > 0) {
            eqStr += (B_coef === 1 ? 'y' : `${B_coef}y`);
          } else {
            eqStr += (B_coef === -1 ? '- y' : `${B_coef}y`);
          }
        } else {
          // 否则后续用 formatTerm
          eqStr += ' ' + formatTerm(B_coef, 'y');
        }
      }

      // 处理 C_coef
      if (C_coef !== 0) {
        // 如果前面都没输出，就相当于第一个项
        if (!eqStr) {
          eqStr = (C_coef > 0) ? `${C_coef}` : `${C_coef}`;
        } else {
          eqStr += ' ' + formatTerm(C_coef, '');
        }
      }

      // 如果所有系数都为0
      if (!eqStr) {
        eqStr = '0';
      }

      // 去掉开头多余的 '+'
      eqStr = eqStr.replace(/^\+\s*/, '').trim();
      // 最后补 "= 0"
      eqStr += ' = 0';

      // 显示到界面
      equationText.textContent = `${eqStr}`;

      // === 计算直线在 SVG 中的可视化绘制（浮点，不做取整）===
      // 根据 A, B, C 在 [-gridRangeX, gridRangeX] 范围内画线
      //   y = (-A x - C) / B
      let x1, y1, x2, y2;

      // 如果 B_coef 不为零
      if (Math.abs(B_coef) > 1e-10) {
        x1 = -config.gridRangeX;
        y1 = (-A_coef * x1 - C_coef) / B_coef;
        x2 = config.gridRangeX;
        y2 = (-A_coef * x2 - C_coef) / B_coef;
      } else if (Math.abs(A_coef) > 1e-10) {
        // 当 B_coef 为零，且 A_coef 不为零时，直线平行于 y 轴
        x1 = -config.gridRangeX;
        y1 = -config.gridRangeY;
        x2 = -config.gridRangeX;
        y2 = config.gridRangeY;
      } else {
        // 当 A_coef 和 B_coef 都为零，直线退化为常数
        x1 = -config.gridRangeX;
        y1 = 0;
        x2 = config.gridRangeX;
        y2 = 0;
      }

      // 限制 y1 和 y2 在网格范围内
      if (Math.abs(B_coef) > 1e-10) {
        if (y1 > config.gridRangeY) {
          y1 = config.gridRangeY;
          x1 = (-B_coef * y1 - C_coef) / A_coef;
        }
        if (y1 < -config.gridRangeY) {
          y1 = -config.gridRangeY;
          x1 = (-B_coef * y1 - C_coef) / A_coef;
        }
        if (y2 > config.gridRangeY) {
          y2 = config.gridRangeY;
          x2 = (-B_coef * y2 - C_coef) / A_coef;
        }
        if (y2 < -config.gridRangeY) {
          y2 = -config.gridRangeY;
          x2 = (-B_coef * y2 - C_coef) / A_coef;
        }
      }

      // 转换回像素单位
      x1 *= config.scale;
      y1 *= config.scale;
      x2 *= config.scale;
      y2 *= config.scale;

      // 更新直线 AB 的位置
      lineVector.setAttribute('x1', x1);
      lineVector.setAttribute('y1', -y1);
      lineVector.setAttribute('x2', x2);
      lineVector.setAttribute('y2', -y2);

      // 更新法向量
      updateNormalVector(A_coef, B_coef);
    }

    /**
     * 更新法向量的位置
     * 法向量为 ((0,0),(A, B))
     */
    function updateNormalVector(A, B) {
      // 法向量在网格单位
      const nx = A;
      const ny = B;

      // 转换为像素单位
      const pixel_nx = nx * config.scale;
      const pixel_ny = ny * config.scale;

      // 设置法向量的终点
      normalLine.setAttribute('x2', pixel_nx);
      normalLine.setAttribute('y2', -pixel_ny);

      // 更新法向量标签的位置和内容
      // 将标签放在法向量终点的旁边
      const labelOffset = 15; // 增加偏移量以避免重叠
      let labelX = pixel_nx;
      let labelY = -pixel_ny;

      // 调整标签位置以避免重叠
      if (pixel_nx >= 0) {
        labelX += labelOffset;
      } else {
        labelX -= labelOffset;
      }

      if (pixel_ny >= 0) {
        labelY -= labelOffset;
      } else {
        labelY += labelOffset;
      }

      // 格式化数值，确保显示两位小数
      const formattedA = A.toFixed(2);
      const formattedB = B.toFixed(2);

      // 更新标签文本内容
      normalText.textContent = `法向量 (${formattedA}, ${formattedB})`;
      normalText.setAttribute('x', labelX);
      normalText.setAttribute('y', labelY);
    }
    
    /**
     * 处理点的拖动
     */
    let activePoint = null;
    let startX, startY;
    
    function startPointDrag(e, point) {
      // 仅在左键点击时开始拖动
      if (e.button !== 0) return;
      e.preventDefault();
      activePoint = point;
      const pt = svg.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
      startX = svgP.x - parseFloat(point.getAttribute('cx'));
      startY = svgP.y - parseFloat(point.getAttribute('cy'));
    }
    
    pointA.addEventListener('mousedown', (e) => startPointDrag(e, pointA));
    pointB.addEventListener('mousedown', (e) => startPointDrag(e, pointB));
    
    document.addEventListener('mousemove', (e) => {
      if (activePoint) {
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        const newX = svgP.x - startX;
        const newY = svgP.y - startY;
    
        // [修改重点] 移动时直接用浮动值，不进行网格吸附
        activePoint.setAttribute('cx', newX);
        activePoint.setAttribute('cy', newY);
    
        // 同步更新文字标签
        const text = (activePoint.id === 'pointA') ? pointAText : pointBText;
        text.setAttribute('x', newX + 10);
        text.setAttribute('y', newY + 10);
    
        // 更新显示(标签 & 直线 & 法向量)
        updatePointLabel(activePoint, text);
        updateLine(); // 即时刷新直线和法向量
      }
    });
    
    // [修改重点] 在 mouseup 时进行网格吸附
    document.addEventListener('mouseup', (e) => {
      if (activePoint) {
        // 松开后再吸附到网格
        snapToGrid();
      }
      activePoint = null;
    });
    
    /**
     * 添加滚轮事件监听器，实现缩放功能
     */
    svg.addEventListener('wheel', (e) => {
      e.preventDefault(); // 防止页面滚动

      const delta = e.deltaY;
      if (delta < 0) {
        // 向上滚动，放大
        config.scale = Math.min(config.scale + 5, config.maxScale);
      } else {
        // 向下滚动，缩小
        config.scale = Math.max(config.scale - 5, config.minScale);
      }
      
      // 动态计算新的网格范围
      calculateGridRange();

      // 重新绘制网格
      drawGrid();
      
      // 吸附所有点到最近的网格点
      snapToGrid();
    }, { passive: false }); // 设置 passive 为 false 以便调用 preventDefault
    
    /**
     * 添加平移功能（右键控制）
     */
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let currentTranslate = { x: 150, y: 450 }; // 初始中心点
    
    /**
     * 更新 grid 的 transform
     */
    function updateGridTransform() {
      gridGroup.setAttribute('transform', `translate(${currentTranslate.x},${currentTranslate.y})`);
      calculateGridRange();
      drawGrid();
      updateAllPoints();
    }
    
    // 监听鼠标按下开始平移（仅右键）
    container.addEventListener('mousedown', (e) => {
      // 检查是否是右键
      if (e.button === 2) {
        isPanning = true;
        panStart.x = e.clientX;
        panStart.y = e.clientY;
        container.classList.add('grabbing');
      }
    });
    
    // 监听鼠标移动进行平移
    document.addEventListener('mousemove', (e) => {
      if (isPanning) {
        const dx = e.clientX - panStart.x;
        const dy = e.clientY - panStart.y;
        panStart.x = e.clientX;
        panStart.y = e.clientY;
        currentTranslate.x += dx;
        currentTranslate.y += dy;
        gridGroup.setAttribute('transform', `translate(${currentTranslate.x},${currentTranslate.y})`);
        calculateGridRange();
        drawGrid();
        updateAllPoints();
      }
    });
    
    // 监听鼠标释放结束平移
    document.addEventListener('mouseup', () => {
      if (isPanning) {
        isPanning = false;
        container.classList.remove('grabbing');
      }
    });
    
    // 禁止在SVG内部拖动时触发平移
    svg.addEventListener('mousedown', (e) => {
      if (e.button === 2) {
        // 如果点击的是点或文本，阻止平移
        if (e.target.tagName === 'circle' || e.target.tagName === 'text') {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    });
    
    // 禁止右键菜单
    container.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
    
    // 初始化
    calculateGridRange();
    drawGrid();
    snapToGrid(); // 在初始化时吸附所有点到网格
  </script>
</body>
</html>
