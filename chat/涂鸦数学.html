<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数学解题工具</title>

    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: {
                fontCache: 'global'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            width: 100%;
            max-width: 1500px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            box-sizing: border-box;
        }
        .left-panel {
            flex: 1;
            min-width: 300px;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .right-panel {
            flex: 1;
            min-width: 300px;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
        }
        
        /* 响应式布局 */
        @media screen and (max-width: 992px) {
            .container {
                padding: 15px;
                gap: 10px;
            }
            .left-panel, .right-panel {
                flex: 100%;
                min-width: 100%;
            }
        }
        
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
            }
        }
        
        @media screen and (max-width: 480px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 8px;
                border-radius: 5px;
            }
            .canvas-buttons {
                flex-direction: column;
            }
            .canvas-buttons button {
                margin-bottom: 5px;
            }
            input, select, textarea {
                padding: 8px;
                font-size: 14px;
            }
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
        h1 {
            color: #2a2a72;
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            font-size: 28px;
        }
        h2 {
            color: #2a2a72;
            margin-bottom: 15px;
            font-size: 22px;
        }
        h3 {
            color: #2a2a72;
            margin-bottom: 12px;
            font-size: 18px;
        }
        .panel-title {
            margin-top: 0;
            margin-bottom: 8px;
            color: #2a2a72;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 8px;
            font-weight: 600;
        }
        .panel-description {
            margin-top: 0;
            margin-bottom: 15px;
            font-style: italic;
            color: #666;
            font-size: 14px;
        }
        @media screen and (max-width: 768px) {
            h1 {
                font-size: 24px;
                margin-bottom: 20px;
            }
            h2 {
                font-size: 20px;
            }
            h3 {
                font-size: 16px;
            }
        }
        @media screen and (max-width: 480px) {
            h1 {
                font-size: 22px;
                margin-bottom: 15px;
            }
            h2 {
                font-size: 18px;
            }
            h3 {
                font-size: 16px;
            }
        }
        .form-group {
            margin-bottom: 20px;
            width: 100%;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
        }
        button {
            background-color: #2a2a72;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #1a1a62;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .status-area {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            background-color: #f9f9f9;
        }
        .status-message {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #2a2a72;
        }
        .error-message {
            color: #d9534f;
            border-left: 3px solid #d9534f;
        }
        .result-area {
            margin-top: 30px;
            text-align: center;
            width: 100%;
            min-height: 900px; /* 添加最小高度 */
        }
        .result-image {
            max-width: 100%;
            height: auto;
            max-height: calc(100vh - 300px);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            object-fit: contain;
        }
        /* 粘贴区域的样式 */
        .paste-area {
            width: 100%;
            height: 150px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
            background-color: #f9f9f9;
            margin-bottom: 10px;
        }
        .paste-area:hover {
            border-color: #2a2a72;
            background-color: #f1f1f9;
        }
        .paste-area p {
            margin: 0;
            color: #666;
        }
        .paste-img-preview {
            max-width: 100%;
            max-height: 140px;
            margin-top: 10px;
            border-radius: 4px;
            display: none;
        }
        /* 历史记录样式 */
        .history-panel {
            margin-top: 30px;
            width: 100%;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .history-toggle {
            cursor: pointer;
            font-weight: 600;
            color: #2a2a72;
            display: flex;
            align-items: center;
        }
        .history-toggle::after {
            content: '▼';
            margin-left: 8px;
            font-size: 12px;
        }
        .history-toggle.collapsed::after {
            content: '▶';
        }
        .history-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        @media screen and (min-width: 992px) {
            .history-content {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }
        .history-content.collapsed {
            display: none;
        }
        .history-clear {
            background-color: #f8d7da;
            color: #721c24;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            border: 1px solid #f5c6cb;
        }
        .history-clear:hover {
            background-color: #f5c6cb;
        }
        .history-item {
            position: relative;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }
        .history-item:hover {
            transform: translateY(-5px);
        }
        .history-img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }
        .history-info {
            padding: 8px;
            font-size: 12px;
            background-color: rgba(0,0,0,0.03);
        }
        .history-prompt {
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .history-date {
            margin: 3px 0 0;
            color: #666;
            font-size: 11px;
        }
        .history-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }
        .history-action-btn {
            width: 25px;
            height: 25px;
            background-color: rgba(255,255,255,0.8);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .history-action-btn:hover {
            background-color: white;
        }
        .no-history {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            color: #666;
        }
        /* 批量生成进度样式 */
        .batch-progress {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #2a2a72;
        }
        .progress-bar-container {
            height: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background-color: #2a2a72;
            width: 0%;
            transition: width 0.3s;
        }

        /* Canvas styles */
        .canvas-container {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            background-color: #fff;
            margin-bottom: 15px;
            transition: height 0.3s ease;
        }
        @media screen and (min-width: 1200px) {
            .canvas-container {
                height: 400px;
            }
        }
        @media screen and (max-width: 768px) {
            .canvas-container {
                height: 250px;
            }
        }
        #drawingCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
        }
        .canvas-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .canvas-buttons button {
            flex: 1;
            min-width: 80px;
            margin: 0;
            font-size: 14px;
            padding: 8px 12px;
        }
        #eraserBtn {
            background-color: #ff9800;
        }
        #eraserBtn.active {
            background-color: #e65100;
        }
        #clearCanvasBtn {
            background-color: #f44336;
        }
        /* 调色板样式 */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.2s;
            border: 2px solid #f5f5f5;
        }
        .color-option:hover {
            transform: scale(1.1);
        }
        .color-option.active {
            border: 2px solid #333;
            transform: scale(1.1);
        }
        .color-picker {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 12px;
        }
        .color-picker input {
            width: 30px;
            height: 30px;
            padding: 0;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background: transparent;
        }
        .color-picker label {
            margin-top: 4px;
            color: #666;
            font-size: 10px;
            font-weight: normal;
        }
        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #323232;
            color: #fff;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            z-index: 1000;
        }
        .notification.show {
            opacity: 1;
            visibility: visible;
        }
        .notification.success {
            background-color: #4CAF50;
        }
        .notification.error {
            background-color: #f44336;
        }
        .text-result {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            text-align: left;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-height: 1600px;
            min-height: 750px; /* 添加最小高度 */
            height: 750px; /* 添加初始高度 */
            overflow-y: auto;
            position: relative;
        }
        .text-result svg {
            display: block;
            margin: 10px auto;
            max-width: 100%;
            height: auto;
        }
        .text-result img {
            max-width: 100%;
            height: auto;
            margin: 10px auto;
            display: block;
        }
        .text-result * {
            max-width: 100%;
        }
        .text-result code {
            background: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
        }
        .text-result pre {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
        }
        .text-result table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        .text-result th, .text-result td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .text-result th {
            background-color: #f2f2f2;
        }
        .svg-container {
            margin: 15px 0;
            text-align: center;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #eee;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: relative;
            min-height: 50px; /* 确保有足够的空间放置按钮 */
        }
        .svg-container svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px auto;
        }
        .svg-copy-btn {
            margin-top: 5px;
            padding: 4px 8px;
            background-color: #2a2a72;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            display: inline-block;
        }
        .svg-copy-btn:hover {
            background-color: #1a1a62;
        }
        .loading-indicator {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #2a2a72;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .image-loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
            display: none;
        }
        /* 历史记录标签样式 */
        .history-img-container {
            position: relative;
            width: 100%;
            height: 150px;
        }
        .history-type-label {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 3px 8px;
            font-size: 12px;
            border-radius: 12px;
            color: white;
            background-color: rgba(0,0,0,0.6);
        }
        .combined-label {
            background-color: rgba(33, 150, 243, 0.8);
        }
        .text-label {
            background-color: rgba(76, 175, 80, 0.8);
        }
        .image-label {
            background-color: rgba(156, 39, 176, 0.8);
        }
        
        /* 对话历史样式 */
        .conversation-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 500px;
        }
        .conversation-messages {
            overflow-y: auto;
            padding: 10px;
            flex-grow: 1;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
        }
        .message {
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 85%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .user-message {
            align-self: flex-end;
            background-color: #dceafc;
            border-bottom-right-radius: 0;
        }
        .assistant-message {
            align-self: flex-start;
            background-color: white;
            border-bottom-left-radius: 0;
        }
        .message-time {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            text-align: right;
        }
        .conversation-input {
            display: flex;
            padding: 10px;
            background-color: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        .conversation-input input {
            flex-grow: 1;
            margin-right: 10px;
        }
        .conversation-input button {
            margin: 0;
            white-space: nowrap;
        }
        .initial-message {
            color: #666;
            text-align: center;
            padding: 20px;
            font-style: normal;
            line-height: 1.6;
        }
        .initial-message p {
            margin: 10px 0;
        }
        .initial-message ul {
            margin: 15px 0;
        }
        .initial-message li {
            margin: 8px 0;
            color: #2a2a72;
        }
        .prompt-container {
            position: relative;
            width: 100%;
            min-height: 100px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            margin-bottom: 15px;
        }

        #prompt {
            width: 100%;
            min-height: 100px;
            border: none;
            resize: vertical;
            padding: 10px;
            font-size: 16px;
            background: transparent;
        }

        .prompt-image-preview {
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .prompt-image-item {
            position: relative;
            width: 200px;
            margin: 5px;
        }

        .prompt-image-item img {
            width: 100%;
            height: auto;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .prompt-image-item .remove-image {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background-color: #ff4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .prompt-image-item .remove-image:hover {
            background-color: #ff0000;
        }
        /* 其他样式 */
        .message img {
            max-width: 200px;
            max-height: 200px;
            border-radius: 5px;
            margin: 5px 0;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        
        <div class="left-panel">
            <h3 class="panel-title">玖数学手绘问题</h3>
            <div class="form-group">
                <div class="prompt-container">
                    <textarea id="prompt" placeholder="请输入您的数学问题，可以直接粘贴(Ctrl+V)图片...">如图,求解图中的数学问题</textarea>
                    <div id="promptImagePreview" class="prompt-image-preview"></div>

                </div>

            </div>
            <div class="canvas-container">
                <canvas id="drawingCanvas" tabindex="0"></canvas>
            </div>
            <div class="canvas-buttons">
                <button id="clearCanvasBtn">清除</button>
                <button id="eraserBtn">橡皮擦</button>
                <button id="sendCanvasBtn">上传图片</button>
                <button id="generateBtn">解答问题</button>
            </div>
            
            <!-- 添加调色板 -->
            <div class="color-palette">
                <div class="color-option active" data-color="#000000" style="background-color: #000000;"></div>
                <div class="color-option" data-color="#ff0000" style="background-color: #ff0000;"></div>
                <div class="color-option" data-color="#ff9900" style="background-color: #ff9900;"></div>
                <div class="color-option" data-color="#33cc33" style="background-color: #33cc33;"></div>
                <div class="color-option" data-color="#3366ff" style="background-color: #3366ff;"></div>
                <div class="color-option" data-color="#9933ff" style="background-color: #9933ff;"></div>
                <div class="color-option" data-color="#ff66cc" style="background-color: #ff66cc;"></div>
                <div class="color-option" data-color="#663300" style="background-color: #663300;"></div>
                <div class="color-picker">
                    <input type="color" id="customColorPicker" value="#000000">
                    <label for="customColorPicker">自定义</label>
                </div>
            </div>
            
            <div class="form-group" style="display: none;">
                <label for="apiKey">OpenAI API Key:</label>
                <input type="password" id="apiKey" value="sk-X5kUt2ZnRTwu13srkgRYsZljHS4G8SdJNkA3iZYheaFDkiK5" placeholder="Enter your OpenAI API key here">
            </div>
            
            <div class="form-group" style="display: none;">
                <label for="baseUrl">Base URL:</label>
                <input type="text" id="baseUrl" value="https://aigc.x-see.cn/v1/" placeholder="API base URL">
            </div>
            
          
        
        </div>
        
        <div class="right-panel">
            <div class="result-area" id="resultArea">
                <div id="textResult" class="text-result">
                  
                </div>
                
                <!-- 添加对话区域 -->
                <div class="conversation-container" id="conversationContainer" style="display: none;">
                    <div class="conversation-messages" id="conversationMessages">
                        <!-- 对话消息将在这里动态添加 -->
                    </div>
                    <div class="conversation-input">
                        <input type="text" id="followupQuestion" placeholder="输入后续问题...">
                        <button id="sendFollowupBtn">继续提问</button>
                    </div>
                </div>
                
                <div>
                    <button id="saveBtn" style="display: none;">保存结果</button>
                    <button id="continueConversationBtn" style="display: none;">继续对话</button>
                </div>
            </div>

            <!-- 历史记录面板 -->
            <div class="history-panel">
                <div class="status-area" id="statusArea"style="display: none;">
                    <div class="status-message">可直接生成图像。</div>
                </div>
                <div class="history-header">
                    <div class="history-toggle" id="historyToggle">历史记录</div>
                    <button class="history-clear" id="historyClear">清空历史</button>
                </div>
                <div class="history-content" id="historyContent">
                    <!-- 历史记录项将由JavaScript动态添加 -->
                    <div class="no-history">暂无历史记录</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 通知元素 -->
    <div id="notification" class="notification"></div>

    <script>
        // Model configurations
        const MODEL_CONFIGS = {
            "o4-mini": {
                "api_endpoint": "chat/completions",
                "supports_image_input": true,
                "description": "文字解答(支持图片输入)"
            }
        };

        // DOM elements
        const apiKeyInput = document.getElementById('apiKey');
        const baseUrlInput = document.getElementById('baseUrl');
        const promptInput = document.getElementById('prompt');
        const modelSelect = document.getElementById('model');
        const sizeSelect = document.getElementById('size');
        const generateBtn = document.getElementById('generateBtn');
        const statusArea = document.getElementById('statusArea');
        const resultArea = document.getElementById('resultArea');
        const resultImage = document.getElementById('resultImage');
        const saveBtn = document.getElementById('saveBtn');
        const inputImageOptionsDiv = document.getElementById('inputImageOptions');
        const inputImageDiv = document.getElementById('inputImage');
        const imageUrlInput = document.getElementById('imageUrl');
        const pasteArea = document.getElementById('pasteArea');
        const pastePreview = document.getElementById('pastePreview');
        const historyToggle = document.getElementById('historyToggle');
        const historyContent = document.getElementById('historyContent');
        const historyClear = document.getElementById('historyClear');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const sendCanvasBtn = document.getElementById('sendCanvasBtn');
        const notification = document.getElementById('notification');
        const conversationContainer = document.getElementById('conversationContainer');
        const conversationMessages = document.getElementById('conversationMessages');
        const followupQuestion = document.getElementById('followupQuestion');
        const sendFollowupBtn = document.getElementById('sendFollowupBtn');
        const continueConversationBtn = document.getElementById('continueConversationBtn');

        // 存储当前对话历史
        let currentConversation = [];
        
        // 存储粘贴的图片数据
        let pastedImageData = null;
        
        // 存储多个图片数据的数组
        let pastedImagesData = [];
        
        // Canvas drawing functionality
        const ctx = drawingCanvas.getContext('2d');
        let drawing = false;
        let lastX = 0;
        let lastY = 0;
        let isEraser = false;
        let lastTime = 0;
        let lastSpeed = 0;
        const MIN_LINE_WIDTH = 0.5;
        const MAX_LINE_WIDTH = 16;
        let currentColor = '#000000'; // 当前选择的颜色

        // Initialize canvas
        function initializeCanvas() {
            drawingCanvas.width = drawingCanvas.offsetWidth;
            drawingCanvas.height = drawingCanvas.offsetHeight;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 2;
            ctx.strokeStyle = currentColor;
        }

        // Drawing functions
        function startDrawing(x, y) {
            drawing = true;
            [lastX, lastY] = [x, y];
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
        }

        function stopDrawing() {
            drawing = false;
        }

        function draw(x, y, pressure = 1) {
            if (!drawing) return;
            
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            if (isEraser) {
                // Calculate movement speed
                const currentTime = Date.now();
                const timeDiff = currentTime - lastTime;
                const distance = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
                const speed = timeDiff > 0 ? distance / timeDiff : 0;
                
                // Smooth speed changes
                lastSpeed = lastSpeed * 0.7 + speed * 0.3;
                
                const baseWidth = 20;
                const speedFactor = Math.min(lastSpeed * 2, 3);
                const pressureFactor = pressure > 0 ? pressure : 1;
                ctx.lineWidth = baseWidth * (speedFactor + pressureFactor);
                ctx.strokeStyle = '#ffffff';
                
                lastTime = currentTime;
            } else {
                ctx.strokeStyle = currentColor; // 使用当前选择的颜色
                ctx.lineWidth = pressure > 0 ? 
                    Math.min(MAX_LINE_WIDTH, Math.max(MIN_LINE_WIDTH, pressure * MAX_LINE_WIDTH)) : 2;
            }
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            [lastX, lastY] = [x, y];
        }

        // Canvas event listeners
        drawingCanvas.addEventListener('mousedown', (e) => {
            startDrawing(e.offsetX, e.offsetY);
        });

        drawingCanvas.addEventListener('mousemove', (e) => {
            draw(e.offsetX, e.offsetY);
        });

        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);

        // Add paste event listener to canvas
        drawingCanvas.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let blob = null;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') === 0) {
                    blob = items[i].getAsFile();
                    break;
                }
            }
            
            if (blob) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        // Clear canvas
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        // Calculate dimensions to center the image
                        let width = img.width;
                        let height = img.height;
                        let x = 0;
                        let y = 0;
                        
                        // Scale image if needed
                        const maxWidth = drawingCanvas.width * 0.9; // 90% of canvas width
                        const maxHeight = drawingCanvas.height * 0.9; // 90% of canvas height
                        
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        
                        // Center image
                        x = (drawingCanvas.width - width) / 2;
                        y = (drawingCanvas.height - height) / 2;
                        
                        // Draw image on canvas
                        ctx.drawImage(img, x, y, width, height);
                        
                        showNotification('图片已粘贴到画布上并居中显示');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(blob);
            }
        });
        
        // Make canvas focusable so it can receive paste events
        drawingCanvas.setAttribute("tabindex", "0");
        drawingCanvas.addEventListener('click', function() {
            this.focus();
        });

        // Touch events
        drawingCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = drawingCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            startDrawing(x, y);
        });

        drawingCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = drawingCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            draw(x, y, touch.force || 1);
        });

        drawingCanvas.addEventListener('touchend', stopDrawing);
        drawingCanvas.addEventListener('touchcancel', stopDrawing);

        // Pointer events
        drawingCanvas.addEventListener('pointerdown', (e) => {
            if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
                e.preventDefault();
                if (e.buttons === 32 || isEraser) {
                    isEraser = true;
                    lastTime = Date.now();
                    lastSpeed = 0;
                }
                startDrawing(e.offsetX, e.offsetY);
            }
        });

        drawingCanvas.addEventListener('pointermove', (e) => {
            if (!drawing) return;
            e.preventDefault();
            draw(e.offsetX, e.offsetY, e.pressure);
        });

        drawingCanvas.addEventListener('pointerup', (e) => {
            stopDrawing();
            if (isEraser && !eraserBtn.classList.contains('active')) {
                isEraser = false;
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 2;
            }
        });

        drawingCanvas.addEventListener('pointerout', stopDrawing);
        drawingCanvas.addEventListener('pointercancel', stopDrawing);

        // Canvas button events
        clearCanvasBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            showNotification('画布已清除');
        });

        eraserBtn.addEventListener('click', () => {
            isEraser = !isEraser;
            
            if (isEraser) {
                ctx.strokeStyle = '#ffffff';
                drawingCanvas.style.cursor = 'not-allowed';
                showNotification('橡皮擦模式已启用');
                eraserBtn.classList.add('active');
            } else {
                ctx.strokeStyle = currentColor; // 恢复为当前选择的颜色
                drawingCanvas.style.cursor = 'crosshair';
                showNotification('绘图模式已启用');
                eraserBtn.classList.remove('active');
            }
        });

        sendCanvasBtn.addEventListener('click', () => {
            drawingCanvas.toBlob((blob) => {
                const reader = new FileReader();
                reader.onloadend = function() {
                    // Convert canvas to base64 image data
                    const base64data = reader.result;
                    
                    // Set this as the input image
                    pastedImageData = base64data;
                    
                    // Make sure we're using a model that supports image input
                    if (!MODEL_CONFIGS[modelSelect.value].supports_image_input) {
                        modelSelect.value = 'gpt-4o-image';
                        const event = new Event('change');
                        modelSelect.dispatchEvent(event);
                    }
                    
                    // Update UI to show the image is selected
                    pastePreview.src = base64data;
                    pastePreview.style.display = 'block';
                    inputImageOptionsDiv.style.display = 'block';
                    
                    showNotification('草图已准备好，可以生成图像了');
                    addStatus('草图已添加! 准备好生成图像了。');
                };
                reader.readAsDataURL(blob);
            });
        });

        // Notification function
        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = `notification show ${type}`;

            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // Window resize handler for canvas
        window.addEventListener('resize', () => {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = drawingCanvas.width;
            tempCanvas.height = drawingCanvas.height;
            tempCtx.drawImage(drawingCanvas, 0, 0);

            drawingCanvas.width = drawingCanvas.offsetWidth;
            drawingCanvas.height = drawingCanvas.offsetHeight;

            // Reinitialize canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 2;
            ctx.strokeStyle = currentColor;

            // Redraw previous content
            ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, drawingCanvas.width, drawingCanvas.height);
        });

        // 提示词分类和内容

        
        // 显示子分类
        function showSubcategory() {
            const category = document.getElementById('promptCategory').value;
            const subcategoryContainer = document.getElementById('subcategoryContainer');
            const subcategorySelect = document.getElementById('promptSubcategory');
            
            // 清空现有选项，保留第一个默认选项
            subcategorySelect.innerHTML = '<option value="">-- 选择具体问题类型 --</option>';
            
            if (category && promptsData[category]) {
                // 填充子分类选项
                promptsData[category].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.value;
                    option.textContent = item.label;
                    subcategorySelect.appendChild(option);
                });
                
                // 显示子分类下拉框
                subcategoryContainer.style.display = 'block';
            } else {
                // 隐藏子分类下拉框
                subcategoryContainer.style.display = 'none';
            }
        }
        
        // 将选择的提示词添加到文本域
        function addPromptToTextarea() {
            const selectedPrompt = document.getElementById('promptSubcategory').value;
            if (selectedPrompt) {
                const promptTextarea = document.getElementById('prompt');
                // 检查当前文本是否为默认文本，如果是则清空
                if (promptTextarea.value === '求解方程：x² + 5x + 6 = 0') {
                    promptTextarea.value = selectedPrompt;
                } else {
                    // 否则在末尾添加新行
                    promptTextarea.value = promptTextarea.value.trim() + '\n' + selectedPrompt;
                }
                
                // 显示通知
                showNotification('已添加问题到输入框');
                addStatus(`已添加问题: "${selectedPrompt}"`);
            }
        }

        // Initialize the page
        window.onload = function() {
            // Initialize the canvas
            initializeCanvas();
            
            // Show initial paste hint
            addStatus('提示: 点击画布后可直接使用Ctrl+V粘贴图片到画布上');
            
            // 初始检查模型是否支持图像输入
            const supportsImage = MODEL_CONFIGS[modelSelect.value].supports_image_input;
            inputImageOptionsDiv.style.display = supportsImage ? 'block' : 'none';
            
            // 加载历史记录
            loadHistory();
            
            // 清除图片按钮事件处理
            const clearImageBtn = document.getElementById('clearImageBtn');
            clearImageBtn.addEventListener('click', function() {
                // 清除图片数据
                pastedImageData = null;
                pastePreview.src = '';
                pastePreview.style.display = 'none';
                imageUrlInput.value = '';
                
                // 显示通知
                showNotification('图片已清除');
                addStatus('已清除所有图片输入。');
            });
            
            // 初始化提示词数据
            initPromptsData();
            
            // 设置调色板功能
            initializeColorPalette();
            
            // 初始化对话界面
            continueConversationBtn.style.display = 'none';
            conversationContainer.style.display = 'none';
            
            // Update UI when model changes
            modelSelect.addEventListener('change', function() {
                const selectedModel = this.value;
                const modelConfig = MODEL_CONFIGS[selectedModel];
                const sizes = modelConfig.sizes;
                
                // Update size options
                sizeSelect.innerHTML = '';
                sizes.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size;
                    option.textContent = size;
                    sizeSelect.appendChild(option);
                });
                
                // Show/hide input image options based on model capability
                const supportsImage = modelConfig.supports_image_input;
                inputImageOptionsDiv.style.display = supportsImage ? 'block' : 'none';
                
                if (supportsImage) {
                    addStatus(`已切换到解答模式: ${modelConfig.description}。可以使用图像输入。`);
                } else {
                    addStatus(`已切换到解答模式: ${modelConfig.description}。该模式不支持图像输入。`, true);
                    // Clear any existing image data
                    pastedImageData = null;
                    pastePreview.style.display = 'none';
                }
            });
            
            // Handle paste events for the paste area
            pasteArea.addEventListener('click', function() {
                // Try to paste from clipboard
                navigator.clipboard.read().then(items => {
                    for (const item of items) {
                        if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                            item.getType('image/png').then(blob => {
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    pastedImageData = e.target.result;
                                    pastePreview.src = pastedImageData;
                                    pastePreview.style.display = 'block';
                                    
                                    // Clear URL input to avoid conflicts
                                    imageUrlInput.value = '';
                                    
                                    addStatus('图片已添加! 准备用于生成。');
                                };
                                reader.readAsDataURL(blob);
                            });
                        }
                    }
                }).catch(e => {
                    addStatus('请点击后使用Ctrl+V粘贴图片，或拖拽图片到此区域。');
                });
            });
            
            // Handle drag and drop
            pasteArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.style.borderColor = '#2a2a72';
                this.style.backgroundColor = '#f0f0f9';
            });
            
            pasteArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.style.borderColor = '#ccc';
                this.style.backgroundColor = '#f9f9f9';
            });
            
            pasteArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.style.borderColor = '#ccc';
                this.style.backgroundColor = '#f9f9f9';
                
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0 && files[0].type.indexOf('image') === 0) {
                    const file = files[0];
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        pastedImageData = e.target.result;
                        pastePreview.src = pastedImageData;
                        pastePreview.style.display = 'block';
                        
                        // Clear URL input to avoid conflicts
                        imageUrlInput.value = '';
                        
                        addStatus('图片已添加! 准备用于生成。');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Handle paste events globally
            document.addEventListener('paste', function(e) {
                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                let blob = null;
                
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') === 0) {
                        blob = items[i].getAsFile();
                        break;
                    }
                }
                
                if (blob && MODEL_CONFIGS[modelSelect.value].supports_image_input) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        pastedImageData = e.target.result;
                        pastePreview.src = pastedImageData;
                        pastePreview.style.display = 'block';
                        
                        // Clear URL input to avoid conflicts
                        imageUrlInput.value = '';
                        
                        addStatus('图片已添加! 准备用于生成。');
                    };
                    reader.readAsDataURL(blob);
                }
            });
        };

        // 历史记录相关函数
        function loadHistory() {
            const history = JSON.parse(localStorage.getItem('openai_image_history') || '[]');
            updateHistoryDisplay(history);
        }
        
        function saveToHistory(data) {
            const history = JSON.parse(localStorage.getItem('openai_image_history') || '[]');
            // 将新的记录添加到顶部
            history.unshift(data);
            // 只保留最近的30条记录
            if (history.length > 30) {
                history.pop();
            }
            localStorage.setItem('openai_image_history', JSON.stringify(history));
            updateHistoryDisplay(history);
        }
        
        function updateHistoryDisplay(history) {
            historyContent.innerHTML = '';
            
            if (history.length === 0) {
                const noHistory = document.createElement('div');
                noHistory.className = 'no-history';
                noHistory.textContent = '暂无历史记录';
                historyContent.appendChild(noHistory);
                return;
            }
            
            history.forEach((item, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                // 创建信息区域
                const infoDiv = document.createElement('div');
                infoDiv.className = 'history-info';
                
                // 创建提示词显示
                const promptP = document.createElement('p');
                promptP.className = 'history-prompt';
                promptP.title = item.prompt;
                promptP.textContent = item.prompt;
                
                // 创建日期显示
                const dateP = document.createElement('p');
                dateP.className = 'history-date';
                dateP.textContent = new Date(item.timestamp).toLocaleString();
                
                // 创建操作按钮区域
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'history-actions';
                
                // 创建删除按钮
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'history-action-btn';
                deleteBtn.innerHTML = '&#x2715;'; // ×符号
                deleteBtn.title = '删除';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeHistoryItem(index);
                };
                
                // 创建使用提示词按钮
                const usePromptBtn = document.createElement('div');
                usePromptBtn.className = 'history-action-btn';
                usePromptBtn.innerHTML = '&#x270E;'; // 铅笔符号
                usePromptBtn.title = '使用此问题';
                usePromptBtn.onclick = (e) => {
                    e.stopPropagation();
                    promptInput.value = item.prompt;
                    addStatus(`已加载问题: "${item.prompt}"`);
                };
                
                // 点击事件
                historyItem.onclick = () => {
                    // 准备显示结果区域
                    resultArea.style.display = 'block';

                    // 重置显示内容
                    document.getElementById('textResult').innerHTML = '';
                    
                    // 显示文字答案
                    if (item.textResponse) {
                        const textResult = document.getElementById('textResult');
                        textResult.style.display = 'block';
                        
                        // 创建一个新的容器元素
                        const responseContainer = document.createElement('div');
                        responseContainer.innerHTML = item.textResponse;
                        textResult.appendChild(responseContainer);
                        
                        // 处理可能包含的SVG内容
                        processSvgContent(responseContainer);
                        
                        // 渲染数学公式
                        setTimeout(() => {
                            if (window.MathJax) {
                                window.MathJax.typeset();
                            }
                        }, 100);
                    } else {
                        document.getElementById('textResult').style.display = 'none';
                    }
                };
                
                // 组装各个元素
                actionsDiv.appendChild(usePromptBtn);
                actionsDiv.appendChild(deleteBtn);
                
                infoDiv.appendChild(promptP);
                infoDiv.appendChild(dateP);
                
                historyItem.appendChild(infoDiv);
                historyItem.appendChild(actionsDiv);
                
                historyContent.appendChild(historyItem);
            });
        }
        
        function removeHistoryItem(index) {
            const history = JSON.parse(localStorage.getItem('openai_image_history') || '[]');
            history.splice(index, 1);
            localStorage.setItem('openai_image_history', JSON.stringify(history));
            updateHistoryDisplay(history);
        }
        
        // 处理历史记录面板的折叠与展开
        historyToggle.addEventListener('click', function() {
            this.classList.toggle('collapsed');
            historyContent.classList.toggle('collapsed');
        });
        
        // 处理清空历史记录
        historyClear.addEventListener('click', function() {
            if (confirm('确定要清空所有历史记录吗？此操作不可恢复。')) {
                localStorage.removeItem('openai_image_history');
                updateHistoryDisplay([]);
                addStatus('历史记录已清空');
            }
        });

        // 初始化调色板功能
        function initializeColorPalette() {
            const colorOptions = document.querySelectorAll('.color-option');
            const customColorPicker = document.getElementById('customColorPicker');
            
            // 为每个颜色选项添加点击事件
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    // 移除所有active类
                    colorOptions.forEach(opt => opt.classList.remove('active'));
                    // 给当前选中的添加active类
                    this.classList.add('active');
                    // 更新当前颜色
                    currentColor = this.getAttribute('data-color');
                    // 同步更新自定义颜色选择器的值
                    customColorPicker.value = currentColor;
                    // 如果不是橡皮擦模式，更新绘图颜色
                    if (!isEraser) {
                        ctx.strokeStyle = currentColor;
                    }
                    showNotification(`颜色已切换为: ${currentColor}`);
                });
            });
            
            // 为自定义颜色选择器添加事件
            customColorPicker.addEventListener('input', function() {
                // 更新当前颜色
                currentColor = this.value;
                // 移除所有active类
                colorOptions.forEach(opt => opt.classList.remove('active'));
                // 如果不是橡皮擦模式，更新绘图颜色
                if (!isEraser) {
                    ctx.strokeStyle = currentColor;
                }
                showNotification(`自定义颜色: ${currentColor}`);
            });
        }

        // Add status message
        function addStatus(message, isError = false) {
            const statusMessage = document.createElement('div');
            statusMessage.className = isError ? 'status-message error-message' : 'status-message';
            statusMessage.textContent = message;
            statusArea.appendChild(statusMessage);
            statusArea.scrollTop = statusArea.scrollHeight;
        }

        // Generate image with DALL-E 3
        async function generateDallE3Image(apiKey, baseUrl, prompt, size) {
            try {
                const endpoint = `${baseUrl.replace(/\/$/, '')}/images/generations`;
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        n: 1,
                        model: 'dall-e-3',
                        size: size
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    return {
                        success: false,
                        error: errorData.error?.message || `API error: ${response.status} ${response.statusText}`
                    };
                }
                
                const data = await response.json();
                if (data.data && data.data.length > 0 && data.data[0].url) {
                    return {
                        success: true,
                        imageUrl: data.data[0].url
                    };
                } else {
                    return {
                        success: false,
                        error: 'No image URL found in response'
                    };
                }
            } catch (error) {
                console.error('Error generating DALL-E image:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Generate image with GPT-4o focusing on graphical content
        async function generateGPT4oImage(apiKey, baseUrl, prompt, size, imageUrl = null) {
            try {
                // 显示图像加载消息
                document.getElementById('imageLoadingMessage').style.display = 'block';
                document.getElementById('resultImage').style.display = 'none';
                
                const endpoint = `${baseUrl.replace(/\/$/, '')}/chat/completions`;
                
                // 优化提示词，专注于图形内容
                const enhancedPrompt = `请为以下数学问题创建一个清晰的图形解答：${prompt}
                
重要提示：
1. 专注于绘制文字难以清晰描述的图形内容，如几何图形、坐标系、函数图像、矢量图等
2. 使用适当的数学符号和标注，确保图形清晰可读
3. 若问题需要多步解答，可以创建多个小图展示解题过程
4. 避免在图中重复大段文字解释，文字解释会单独提供
5. 保持图形简洁、专业，使用合适的颜色和标注`;

                // Prepare messages content
                const messagesContent = [
                    {
                        "type": "text",
                        "text": enhancedPrompt
                    }
                ];
                
                // Add image to content if URL is provided
                if (imageUrl) {
                    // 检查是否为Base64图片数据
                    if (imageUrl.startsWith('data:image')) {
                        addStatus(`使用上传的图片作为参考进行解答...`);
                        messagesContent.push({
                            "type": "image_url",
                            "image_url": {
                                "url": imageUrl
                            }
                        });
                    } else {
                        addStatus(`使用图片URL作为参考进行解答: ${imageUrl}`);
                        messagesContent.push({
                            "type": "image_url",
                            "image_url": {
                                "url": imageUrl
                            }
                        });
                    }
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-image',
                        messages: [
                            {
                                "role": "user",
                                "content": messagesContent
                            }
                        ],
                        max_tokens: 500
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    document.getElementById('imageLoadingMessage').style.display = 'none';
                    return {
                        success: false,
                        error: errorData.error?.message || `API error: ${response.status} ${response.statusText}`
                    };
                }
                
                const data = await response.json();
                
                // 隐藏加载消息
                document.getElementById('imageLoadingMessage').style.display = 'none';
                
                if (data.choices && data.choices.length > 0) {
                    const responseContent = data.choices[0].message.content;
                    
                    // Extract image URL from the markdown response
                    const imageUrlMatch = responseContent.match(/!\[.*?\]\((https:\/\/[^\s\)]+)\)/);
                    
                    if (imageUrlMatch) {
                        const imageUrl = imageUrlMatch[1];
                        addStatus(`图片解答已生成`);
                        
                        // 显示图片
                        document.getElementById('resultImage').style.display = 'block';
                        
                        return {
                            success: true,
                            imageUrl: imageUrl
                        };
                    } else {
                        // Try alternative format
                        const downloadLinkMatch = responseContent.match(/\[点击下载\]\((https:\/\/[^\s\)]+)\)/);
                        if (downloadLinkMatch) {
                            const imageUrl = downloadLinkMatch[1];
                            addStatus(`图片解答已生成`);
                            
                            // 显示图片
                            document.getElementById('resultImage').style.display = 'block';
                            
                            return {
                                success: true,
                                imageUrl: imageUrl
                            };
                        } else {
                            return {
                                success: false,
                                error: `无法从响应中提取图片URL: ${responseContent.substring(0, 100)}...`
                            };
                        }
                    }
                } else {
                    return {
                        success: false,
                        error: '从GPT-4o响应中未找到图片信息'
                    };
                }
            } catch (error) {
                console.error('Error generating GPT-4o image:', error);
                document.getElementById('imageLoadingMessage').style.display = 'none';
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Generate text response with GPT-4.1 with streaming
        async function generateGPT41TextResponse(apiKey, baseUrl, prompt, imageUrl = null, withHistory = false) {
            try {
                // 清空文本结果区域
                const textResult = document.getElementById('textResult');
                textResult.innerHTML = '<div class="loading-indicator" id="textLoadingIndicator"></div>';
                document.getElementById('textLoadingIndicator').style.display = 'block';
                
                // 显示结果区域
                document.getElementById('resultArea').style.display = 'block';
                
                const endpoint = `${baseUrl.replace(/\/$/, '')}/chat/completions`;
                
                // 准备消息内容
                let messages = [];
                
                if (withHistory && currentConversation.length > 0) {
                    // 使用完整对话历史
                    messages = currentConversation.map(msg => ({
                        role: msg.role,
                        content: typeof msg.content === 'string' 
                            ? [{ type: "text", text: msg.content }] 
                            : msg.content
                    }));
                } else {
                    // 新对话，仅用当前提示
                    messages = [{
                        role: "user",
                        content: [{
                            type: "text",
                            text: `解答以下数学问题，请给出清晰的步骤和解释。主要聚焦于公式推导、计算和理论解释。
                            
必要时，你可以使用SVG图表来表示关键概念或解题步骤。特别是对于以下内容：
1. 几何图形和空间关系
2. 坐标系和函数图像
3. svg的y值和坐标系的y值是相反的
4. 统计数据和分布
5. 向量和力的分解
6. 流程图和树形结构

请确保：
- 使用SVG格式而非ASCII图表来展示复杂图形
- 使用不同颜色提高图表可读性
- 为SVG添加合适的宽高和视口设置
- 包含必要的标签和图例

问题：${prompt}`
                        }]
                    }];
                    
                    // 初始化新的对话历史
                    currentConversation = [{
                        role: 'user',
                        content: prompt
                    }];
                }
                
                // 如果提供了图片，添加到第一条消息的内容中
                if (imageUrl && messages.length > 0) {
                    // 检查是否为Base64图片数据
                    if (imageUrl.startsWith('data:image')) {
                        addStatus(`使用上传的图片作为参考生成文字解答...`);
                        // 图片添加到第一条消息
                        if (typeof messages[0].content === 'string') {
                            messages[0].content = [
                                { type: "text", text: messages[0].content },
                                { type: "image_url", image_url: { url: imageUrl } }
                            ];
                        } else {
                            messages[0].content.push({ 
                                type: "image_url", 
                                image_url: { url: imageUrl } 
                            });
                        }
                    }
                }
                
                // 创建流式请求
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'o4-mini',
                        messages: messages,
                        stream: true,
                        max_tokens: 10000
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    document.getElementById('textLoadingIndicator').style.display = 'none';
                    return {
                        success: false,
                        error: errorData.error?.message || `API error: ${response.status} ${response.statusText}`
                    };
                }
                
                // 处理流式响应
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let accumulatedResponse = '';
                let buffer = '';
                
                // 创建存储响应的元素
                const responseContainer = document.createElement('div');
                textResult.appendChild(responseContainer);
                
                // 流式读取响应
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    // 解码新接收的数据
                    buffer += decoder.decode(value, { stream: true });
                    
                    // 处理缓冲区中完整的数据行
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // 保留最后一个不完整的行
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        if (line.trim() === 'data: [DONE]') continue;
                        
                        let data;
                        try {
                            // 提取JSON部分
                            const jsonStr = line.replace(/^data: /, '');
                            data = JSON.parse(jsonStr);
                        } catch (error) {
                            console.warn('Failed to parse JSON from line:', line, error);
                            continue;
                        }
                        
                        // 提取文本内容
                        if (data.choices && data.choices.length > 0) {
                            const delta = data.choices[0].delta;
                            if (delta && delta.content) {
                                accumulatedResponse += delta.content;
                                
                                // 安全地设置HTML内容
                                responseContainer.innerHTML = accumulatedResponse;
                                
                                // 尝试解析和处理可能的SVG内容
                                processSvgContent(responseContainer);
                                
                                // 添加MathJax处理
                                try {
                                    if (window.MathJax) {
                                        window.MathJax.typesetPromise([responseContainer]).catch(err => console.log('MathJax error:', err));
                                    }
                                } catch (err) {
                                    console.log('MathJax processing error:', err);
                                }
                                
                                // 滚动到底部
                                textResult.scrollTop = textResult.scrollHeight;
                            }
                        }
                    }
                }
                
                // 隐藏加载指示器
                document.getElementById('textLoadingIndicator').style.display = 'none';
                
                // 确保SVG内容被正确处理
                processSvgContent(responseContainer);
                
                // 添加assistant回应到对话历史
                currentConversation.push({
                    role: 'assistant',
                    content: accumulatedResponse
                });
                
                // 显示继续对话按钮
                continueConversationBtn.style.display = 'inline-block';
                
                return {
                    success: true,
                    textResponse: accumulatedResponse
                };
            } catch (error) {
                console.error('Error generating text response:', error);
                document.getElementById('textLoadingIndicator').style.display = 'none';
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // 处理可能包含的SVG内容
        function processSvgContent(container) {
            // 查找所有代码块，检查是否包含SVG
            const codeBlocks = container.querySelectorAll('pre');
            codeBlocks.forEach(block => {
                const content = block.textContent;
                if (content.trim().startsWith('<svg') && content.includes('</svg>')) {
                    try {
                        // 创建一个新的div来放置SVG
                        const svgContainer = document.createElement('div');
                        svgContainer.classList.add('svg-container');
                        svgContainer.innerHTML = content;
                        
                        // 替换代码块为SVG显示
                        block.parentNode.replaceChild(svgContainer, block);
                        
                        // 处理新创建的SVG
                        addCopyButtonsToSvgs(svgContainer);
                    } catch (err) {
                        console.error('Error processing SVG:', err);
                    }
                }
            });
            
            // 处理可能已存在的SVG
            addCopyButtonsToSvgs(container);
        }
        
        /** 
         * 在给定容器内查找所有 <svg> 并在其后插入"复制 SVG"按钮 
         * @param {HTMLElement} container - 包含 SVG 的父容器
         */
        function addCopyButtonsToSvgs(container) {
            // 找到所有未处理过的 SVG
            const svgs = container.querySelectorAll('svg:not([data-copy-initialized])');
            svgs.forEach(svg => {
                // 标记为已处理，避免重复添加按钮
                svg.setAttribute('data-copy-initialized', 'true');
        
                // 创建按钮
                const btn = document.createElement('button');
                btn.className = 'svg-copy-btn';
                btn.textContent = '复制SVG';
        
                // 点击事件：复制 outerHTML
                btn.addEventListener('click', () => {
                    const svgCode = svg.outerHTML;
                    navigator.clipboard.writeText(svgCode)
                        .then(() => {
                            btn.textContent = '已复制!';
                            showNotification('SVG代码已复制到剪贴板', 'success');
                            setTimeout(() => btn.textContent = '复制SVG', 1500);
                        })
                        .catch(err => {
                            console.error('复制失败', err);
                            btn.textContent = '复制失败';
                            showNotification('复制失败，请重试', 'error');
                            setTimeout(() => btn.textContent = '复制SVG', 1500);
                        });
                });
        
                // 把按钮插入到 SVG 之后
                svg.parentNode.insertBefore(btn, svg.nextSibling);
            });
        }
        
        // 在window加载时初始化MathJax处理
        window.addEventListener('load', function() {
            // 当MathJax排版完成后添加SVG复制按钮
            if (window.MathJax) {
                // 在MathJax加载完成后调用一次
                if (window.MathJax.startup && window.MathJax.startup.promise) {
                    window.MathJax.startup.promise.then(() => {
                        processSvgContent(document.body);
                    });
                }
                
                // 替换typesetPromise方法以在每次排版后调用
                if (window.MathJax.typesetPromise) {
                    const origTypesetPromise = window.MathJax.typesetPromise;
                    window.MathJax.typesetPromise = function(...args) {
                        return origTypesetPromise.apply(this, args).then(() => {
                            setTimeout(() => {
                                processSvgContent(document.body);
                            }, 100); // 稍微延迟确保DOM已更新
                        });
                    };
                }
            }
        });
        
        // 继续对话按钮事件处理
        continueConversationBtn.addEventListener('click', function() {
            // 显示对话容器
            conversationContainer.style.display = 'flex';
            
            // 如果对话历史为空，添加初始消息
            if (conversationMessages.children.length === 0 && currentConversation.length > 0) {
                // 添加已有的对话到对话容器
                currentConversation.forEach(msg => {
                    addConversationMessage(
                        msg.content.type === 'text' ? msg.content : 
                        typeof msg.content === 'string' ? msg.content : 
                        msg.content[0]?.text || '图片输入',
                        msg.role
                    );
                });
            }
            
            // 设置焦点到输入框
            followupQuestion.focus();
        });
        
        // 修改生成按钮的事件处理，支持纯图片发送
        generateBtn.addEventListener('click', async function() {
            const apiKey = apiKeyInput.value.trim();
            const baseUrl = baseUrlInput.value.trim();
            const promptText = promptInput.value.trim();
            const model = 'o4-mini';
            
            // 检查是否有图片或文字输入
            if (!promptText && pastedImagesData.length === 0) {
                addStatus('请输入问题描述或添加图片。', true);
                return;
            }

            // 检查画布是否为空白
            const blankCanvas = document.createElement('canvas');
            blankCanvas.width = drawingCanvas.width;
            blankCanvas.height = drawingCanvas.height;
            const blankCtx = blankCanvas.getContext('2d');
            blankCtx.fillStyle = '#ffffff';
            blankCtx.fillRect(0, 0, blankCanvas.width, blankCanvas.height);
            
            // 比较当前画布与空白画布
            const currentImageData = ctx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height).data;
            const blankImageData = blankCtx.getImageData(0, 0, blankCanvas.width, blankCanvas.height).data;
            
            let isDifferent = false;
            for (let i = 0; i < currentImageData.length; i += 4) {
                if (currentImageData[i] !== blankImageData[i] || 
                    currentImageData[i+1] !== blankImageData[i+1] || 
                    currentImageData[i+2] !== blankImageData[i+2] || 
                    currentImageData[i+3] !== blankImageData[i+3]) {
                    isDifferent = true;
                    break;
                }
            }

            // 如果画布不是空白的，获取画布图片数据
            if (isDifferent) {
                addStatus('检测到画布有内容，将包含画布图片...');
                const canvasImageData = drawingCanvas.toDataURL('image/png');
                pastedImagesData.unshift(canvasImageData);
            }
            
            // 准备所有图片数据
            let allImages = [...pastedImagesData];
            
            generateBtn.disabled = true;
            
            try {
                // 如果没有文字输入但有图片，使用默认提示词
                const finalPromptText = promptText || "请分析并解答图片中的数学问题";
                
                // 生成文字回答(流式)，包含所有图片
                const textResponse = await generateGPT41TextResponse(apiKey, baseUrl, finalPromptText, allImages.length > 0 ? allImages[0] : null);
                
                if (textResponse.success) {
                    addStatus('文字解答生成成功!');
                    
                    resultArea.style.display = 'block';
                    
                    const textResult = document.getElementById('textResult');
                    textResult.innerHTML = textResponse.textResponse;
                    
                    setTimeout(() => {
                        if (window.MathJax) {
                            window.MathJax.typeset();
                        }
                    }, 100);
                    
                    saveToHistory({
                        prompt: finalPromptText,
                        timestamp: Date.now(),
                        model: model,
                        textResponse: textResponse.textResponse,
                        hasImage: allImages.length > 0
                    });
                    
                    saveBtn.style.display = 'inline-block';
                } else {
                    addStatus(`生成答案时发生错误: ${textResponse.error}`, true);
                }
            } catch (error) {
                addStatus(`生成答案过程中发生错误: ${error.message}`, true);
                console.error(error);
            } finally {
                generateBtn.disabled = false;
                if (isDifferent) {
                    pastedImagesData.shift();
                }
            }
        });

        // 添加问题输入框的回车处理
        promptInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // 阻止默认的换行行为
                generateBtn.click(); // 触发生成按钮点击
            }
        });

        // 修改继续对话的输入框，支持图片粘贴和回车发送
        followupQuestion.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendFollowupBtn.click();
            }
        });

        // 为继续对话的输入框添加图片粘贴支持
        followupQuestion.addEventListener('paste', async function(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let blob = null;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') === 0) {
                    blob = items[i].getAsFile();
                    break;
                }
            }
            
            if (blob) {
                e.preventDefault(); // 阻止默认粘贴行为
                
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const imageData = e.target.result;
                    
                    // 直接发送图片作为后续问题
                    currentConversation.push({
                        role: 'user',
                        content: [
                            {
                                type: "image_url",
                                image_url: {
                                    url: imageData
                                }
                            },
                            {
                                type: "text",
                                text: "请分析这张新图片中的问题"
                            }
                        ]
                    });
                    
                    // 在UI中添加图片消息
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message user-message';
                    const img = document.createElement('img');
                    img.src = imageData;
                    img.style.maxWidth = '200px';
                    img.style.maxHeight = '200px';
                    messageDiv.appendChild(img);
                    messageDiv.innerHTML += '<span class="message-time">' + new Date().toLocaleTimeString() + '</span>';
                    conversationMessages.appendChild(messageDiv);
                    
                    // 自动发送
                    await sendFollowupQuestion(true);
                };
                reader.readAsDataURL(blob);
            }
        });

        // 修改发送后续问题的函数，支持图片
        async function sendFollowupQuestion(isImage = false) {
            const followupQuestionText = followupQuestion.value.trim();
            if (followupQuestionText || isImage) {
                if (!isImage) {
                    // 添加文字问题到对话历史
                    currentConversation.push({
                        role: 'user',
                        content: followupQuestionText
                    });
                    // 在UI中添加消息
                    addConversationMessage(followupQuestionText, 'user');
                }
                
                followupQuestion.value = '';
                
                // 禁用按钮，显示加载状态
                sendFollowupBtn.disabled = true;
                let tempMessageDiv = document.createElement('div');
                tempMessageDiv.className = 'message assistant-message';
                tempMessageDiv.innerHTML = '<p>正在思考...</p>';
                conversationMessages.appendChild(tempMessageDiv);
                conversationMessages.scrollTop = conversationMessages.scrollHeight;
                
                try {
                    const response = await fetch(`${baseUrlInput.value.replace(/\/$/, '')}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKeyInput.value}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'o4-mini',
                            messages: currentConversation.map(msg => ({
                                role: msg.role,
                                content: Array.isArray(msg.content) ? msg.content : msg.content
                            })),
                            stream: false,
                            max_tokens: 10000
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const assistantResponse = data.choices[0].message.content;
                    
                    // 添加助手回应到对话历史
                    currentConversation.push({
                        role: 'assistant',
                        content: assistantResponse
                    });
                    
                    // 移除临时消息
                    conversationMessages.removeChild(tempMessageDiv);
                    
                    // 添加真实回应
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message assistant-message';
                    const messageContent = document.createElement('div');
                    messageContent.innerHTML = assistantResponse;
                    
                    // 处理SVG内容
                    processSvgContent(messageContent);
                    
                    messageDiv.appendChild(messageContent);
                    messageDiv.innerHTML += `<span class="message-time">${new Date().toLocaleTimeString()}</span>`;
                    conversationMessages.appendChild(messageDiv);
                    
                    // 处理MathJax
                    if (window.MathJax) {
                        window.MathJax.typesetPromise([messageDiv]).catch(err => console.log('MathJax error:', err));
                    }
                    
                    // 滚动到最新消息
                    conversationMessages.scrollTop = conversationMessages.scrollHeight;
                    
                    addStatus('回复已生成');
                    
                } catch (error) {
                    console.error('Error in conversation:', error);
                    conversationMessages.removeChild(tempMessageDiv);
                    addConversationMessage(`回答生成失败: ${error.message}`, 'assistant');
                    addStatus(`生成答案时发生错误: ${error.message}`, true);
                } finally {
                    sendFollowupBtn.disabled = false;
                }
            }
        }

        function addConversationMessage(message, role) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.classList.add(role === 'user' ? 'user-message' : 'assistant-message');
            messageDiv.innerHTML = '<p>' + message + '</p><span class="message-time">' + new Date().toLocaleTimeString() + '</span>';
            conversationMessages.appendChild(messageDiv);
            conversationMessages.scrollTop = conversationMessages.scrollHeight;
        }

        // 处理问题输入框的粘贴事件
        promptInput.addEventListener('paste', function(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let blob = null;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') === 0) {
                    blob = items[i].getAsFile();
                    break;
                }
            }
            
            if (blob) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const imageData = e.target.result;
                    
                    // 添加到图片数组
                    pastedImagesData.push(imageData);
                    
                    // 更新预览区域
                    updateImagePreviews();
                    
                    showNotification('图片已添加到问题描述中');
                    addStatus('图片已添加到问题描述中');
                };
                reader.readAsDataURL(blob);
            }
        });

        // 更新图片预览
        function updateImagePreviews() {
            const previewDiv = document.getElementById('promptImagePreview');
            previewDiv.innerHTML = '';
            
            pastedImagesData.forEach((imageData, index) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'prompt-image-item';
                
                const img = document.createElement('img');
                img.src = imageData;
                
                const removeBtn = document.createElement('div');
                removeBtn.className = 'remove-image';
                removeBtn.innerHTML = '×';
                removeBtn.onclick = () => removeImage(index);
                
                imageItem.appendChild(img);
                imageItem.appendChild(removeBtn);
                previewDiv.appendChild(imageItem);
            });
        }

        // 移除图片
        function removeImage(index) {
            pastedImagesData.splice(index, 1);
            updateImagePreviews();
            showNotification('图片已移除');
            addStatus('已移除一张图片');
        }
    </script>
</body>
</html> 