<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数学解题工具</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script id="MathJax-script" async src=".\mathjax\mathjax\es5\tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: {
                fontCache: 'global'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            width: 100%;
            max-width: 1500px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            box-sizing: border-box;
        }
        .left-panel {
            flex: 1;
            min-width: 300px;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .right-panel {
            flex: 1;
            min-width: 300px;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
        }
        
        /* 响应式布局 */
        @media screen and (max-width: 992px) {
            .container {
                padding: 15px;
                gap: 10px;
            }
            .left-panel, .right-panel {
                flex: 100%;
                min-width: 100%;
            }
        }
        
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
            }
        }
        
        @media screen and (max-width: 480px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 8px;
                border-radius: 5px;
            }
            .canvas-buttons {
                flex-direction: column;
            }
            .canvas-buttons button {
                margin-bottom: 5px;
            }
            input, select, textarea {
                padding: 8px;
                font-size: 14px;
            }
            button {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
        h1 {
            color: #2a2a72;
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            font-size: 28px;
        }
        h2 {
            color: #2a2a72;
            margin-bottom: 15px;
            font-size: 22px;
        }
        h3 {
            color: #2a2a72;
            margin-bottom: 12px;
            font-size: 18px;
        }
        .panel-title {
            margin-top: 0;
            margin-bottom: 8px;
            color: #2a2a72;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 8px;
            font-weight: 600;
        }
        .panel-description {
            margin-top: 0;
            margin-bottom: 15px;
            font-style: italic;
            color: #666;
            font-size: 14px;
        }
        @media screen and (max-width: 768px) {
            h1 {
                font-size: 24px;
                margin-bottom: 20px;
            }
            h2 {
                font-size: 20px;
            }
            h3 {
                font-size: 16px;
            }
        }
        @media screen and (max-width: 480px) {
            h1 {
                font-size: 22px;
                margin-bottom: 15px;
            }
            h2 {
                font-size: 18px;
            }
            h3 {
                font-size: 16px;
            }
        }
        .form-group {
            margin-bottom: 20px;
            width: 100%;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
        }
        button {
            background-color: #2a2a72;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #1a1a62;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .status-area {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            background-color: #f9f9f9;
        }
        .status-message {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #2a2a72;
        }
        .error-message {
            color: #d9534f;
            border-left: 3px solid #d9534f;
        }
        .result-area {
            margin-top: 30px;
            text-align: center;
            width: 100%;
        }
        .result-image {
            max-width: 100%;
            height: auto;
            max-height: calc(100vh - 300px);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            object-fit: contain;
        }
        /* 粘贴区域的样式 */
        .paste-area {
            width: 100%;
            height: 150px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
            background-color: #f9f9f9;
            margin-bottom: 10px;
        }
        .paste-area:hover {
            border-color: #2a2a72;
            background-color: #f1f1f9;
        }
        .paste-area p {
            margin: 0;
            color: #666;
        }
        .paste-img-preview {
            max-width: 100%;
            max-height: 140px;
            margin-top: 10px;
            border-radius: 4px;
            display: none;
        }
        /* 历史记录样式 */
        .history-panel {
            margin-top: 30px;
            width: 100%;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .history-toggle {
            cursor: pointer;
            font-weight: 600;
            color: #2a2a72;
            display: flex;
            align-items: center;
        }
        .history-toggle::after {
            content: '▼';
            margin-left: 8px;
            font-size: 12px;
        }
        .history-toggle.collapsed::after {
            content: '▶';
        }
        .history-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        @media screen and (min-width: 992px) {
            .history-content {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }
        .history-content.collapsed {
            display: none;
        }
        .history-clear {
            background-color: #f8d7da;
            color: #721c24;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            border: 1px solid #f5c6cb;
        }
        .history-clear:hover {
            background-color: #f5c6cb;
        }
        .history-item {
            position: relative;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }
        .history-item:hover {
            transform: translateY(-5px);
        }
        .history-img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }
        .history-info {
            padding: 8px;
            font-size: 12px;
            background-color: rgba(0,0,0,0.03);
        }
        .history-prompt {
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .history-date {
            margin: 3px 0 0;
            color: #666;
            font-size: 11px;
        }
        .history-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }
        .history-action-btn {
            width: 25px;
            height: 25px;
            background-color: rgba(255,255,255,0.8);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .history-action-btn:hover {
            background-color: white;
        }
        .no-history {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            color: #666;
        }
        /* 批量生成进度样式 */
        .batch-progress {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #2a2a72;
        }
        .progress-bar-container {
            height: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background-color: #2a2a72;
            width: 0%;
            transition: width 0.3s;
        }

        /* Canvas styles */
        .canvas-container {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            background-color: #fff;
            margin-bottom: 15px;
            transition: height 0.3s ease;
        }
        @media screen and (min-width: 1200px) {
            .canvas-container {
                height: 400px;
            }
        }
        @media screen and (max-width: 768px) {
            .canvas-container {
                height: 250px;
            }
        }
        #drawingCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
        }
        .canvas-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .canvas-buttons button {
            flex: 1;
            min-width: 80px;
            margin: 0;
            font-size: 14px;
            padding: 8px 12px;
        }
        #eraserBtn {
            background-color: #ff9800;
        }
        #eraserBtn.active {
            background-color: #e65100;
        }
        #clearCanvasBtn {
            background-color: #f44336;
        }
        /* 调色板样式 */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.2s;
            border: 2px solid #f5f5f5;
        }
        .color-option:hover {
            transform: scale(1.1);
        }
        .color-option.active {
            border: 2px solid #333;
            transform: scale(1.1);
        }
        .color-picker {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 12px;
        }
        .color-picker input {
            width: 30px;
            height: 30px;
            padding: 0;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background: transparent;
        }
        .color-picker label {
            margin-top: 4px;
            color: #666;
            font-size: 10px;
            font-weight: normal;
        }
        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #323232;
            color: #fff;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            z-index: 1000;
        }
        .notification.show {
            opacity: 1;
            visibility: visible;
        }
        .notification.success {
            background-color: #4CAF50;
        }
        .notification.error {
            background-color: #f44336;
        }
        .text-result {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            text-align: left;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-height: 500px;
            overflow-y: auto;
            position: relative;
        }
        .text-result svg {
            display: block;
            margin: 10px auto;
            max-width: 100%;
            height: auto;
        }
        .text-result img {
            max-width: 100%;
            height: auto;
            margin: 10px auto;
            display: block;
        }
        .text-result * {
            max-width: 100%;
        }
        .text-result code {
            background: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
        }
        .text-result pre {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
        }
        .text-result table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        .text-result th, .text-result td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .text-result th {
            background-color: #f2f2f2;
        }
        .svg-container {
            margin: 15px 0;
            text-align: center;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #eee;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .svg-container svg {
            max-width: 100%;
            height: auto;
        }
        .loading-indicator {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #2a2a72;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .image-loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
            display: none;
        }
        /* 历史记录标签样式 */
        .history-img-container {
            position: relative;
            width: 100%;
            height: 150px;
        }
        .history-type-label {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 3px 8px;
            font-size: 12px;
            border-radius: 12px;
            color: white;
            background-color: rgba(0,0,0,0.6);
        }
        .combined-label {
            background-color: rgba(33, 150, 243, 0.8);
        }
        .text-label {
            background-color: rgba(76, 175, 80, 0.8);
        }
        .image-label {
            background-color: rgba(156, 39, 176, 0.8);
        }
        
        /* 对话历史样式 */
        .conversation-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 500px;
        }
        .conversation-messages {
            overflow-y: auto;
            padding: 10px;
            flex-grow: 1;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
        }
        .message {
            padding: 10px 15px;
            border-radius: 10px;
            max-width: 85%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .user-message {
            align-self: flex-end;
            background-color: #dceafc;
            border-bottom-right-radius: 0;
        }
        .assistant-message {
            align-self: flex-start;
            background-color: white;
            border-bottom-left-radius: 0;
        }
        .message-time {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            text-align: right;
        }
        .conversation-input {
            display: flex;
            padding: 10px;
            background-color: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        .conversation-input input {
            flex-grow: 1;
            margin-right: 10px;
        }
        .conversation-input button {
            margin: 0;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        
        <div class="left-panel">
            <h3 class="panel-title">数学问题绘图板</h3>
            <p class="panel-description">在画布上绘制或粘贴(Ctrl+V)图片进行解答</p>
            <div class="canvas-container">
                <canvas id="drawingCanvas" tabindex="0"></canvas>
            </div>
            <div class="canvas-buttons">
                <button id="clearCanvasBtn">清除</button>
                <button id="eraserBtn">橡皮擦</button>
                <button id="sendCanvasBtn">上传图片</button>
                <button id="generateBtn">解答问题</button>
            </div>
            
            <!-- 添加调色板 -->
            <div class="color-palette">
                <div class="color-option active" data-color="#000000" style="background-color: #000000;"></div>
                <div class="color-option" data-color="#ff0000" style="background-color: #ff0000;"></div>
                <div class="color-option" data-color="#ff9900" style="background-color: #ff9900;"></div>
                <div class="color-option" data-color="#33cc33" style="background-color: #33cc33;"></div>
                <div class="color-option" data-color="#3366ff" style="background-color: #3366ff;"></div>
                <div class="color-option" data-color="#9933ff" style="background-color: #9933ff;"></div>
                <div class="color-option" data-color="#ff66cc" style="background-color: #ff66cc;"></div>
                <div class="color-option" data-color="#663300" style="background-color: #663300;"></div>
                <div class="color-picker">
                    <input type="color" id="customColorPicker" value="#000000">
                    <label for="customColorPicker">自定义</label>
                </div>
            </div>
            
            <div class="form-group" style="display: none;">
                <label for="apiKey">OpenAI API Key:</label>
                <input type="password" id="apiKey" value="sk-NKAwMaji6Elw3bXeAxTbkbaQ4zwwhFLKmhCySLJYDPp9tlTZ" placeholder="Enter your OpenAI API key here">
            </div>
            
            <div class="form-group" style="display: none;">
                <label for="baseUrl">Base URL:</label>
                <input type="text" id="baseUrl" value="https://aigc.x-see.cn/v1/" placeholder="API base URL">
            </div>
            
            <div class="form-group">
                <label for="prompt">问题描述:</label>
                <textarea id="prompt" placeholder="请输入您的数学问题...">如图,求解图中的数学问题</textarea>
            </div>
            
            <div class="form-group">
                <label for="promptCategory">问题类型:</label>
                <select id="promptCategory" onchange="showSubcategory()">
                    <option value="">-- 选择问题类型 --</option>
                    <option value="algebra">一、代数</option>
                    <option value="calculus">二、微积分</option>
                    <option value="geometry">三、几何</option>
                    <option value="trigonometry">四、三角函数</option>
                    <option value="statistics">五、统计概率</option>
                    <option value="number_theory">六、数论</option>
                    <option value="linear_algebra">七、线性代数</option>
                    <option value="discrete_math">八、离散数学</option>
                    <option value="complex_analysis">九、复分析</option>
                    <option value="applied_math">十、应用数学</option>
                </select>
            </div>
            
            <div class="form-group" id="subcategoryContainer" style="display: none;">
                <label for="promptSubcategory">具体问题类型:</label>
                <select id="promptSubcategory" onchange="addPromptToTextarea()">
                    <option value="">-- 选择具体问题类型 --</option>
                </select>
            </div>
            
            <div class="form-group"style="display: true;">
                <label for="model">解答方式:</label>
                <select id="model">
                    <option value="combined">文字+图像综合解答</option>
                    <option value="claude-3-7-sonnet-20250219">文字解答(支持图片输入)</option>
                    <option value="gpt-4o-image">仅图像解答</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="size">图像大小:</label>
                <select id="size">
                    <option value="1024x1024">1024x1024</option>
                    <option value="1024x1792">1024x1792</option>
                    <option value="1792x1024">1792x1024</option>
                </select>
            </div>
            
            <div id="inputImageOptions" class="form-group" style="display: none;">
                
                <div id="pasteImage" class="form-group">
                    <label>粘贴图片 (点击或直接Ctrl+V):</label>
                    <div class="paste-area" id="pasteArea">


                        <img id="pastePreview" class="paste-img-preview" alt="粘贴预览">
                    </div>
                    <button id="clearImageBtn" style="margin-top: 10px; background-color: #f44336;">清除图片</button>
                </div>
                
                <div id="inputImage" class="form-group">
                    <label for="imageUrl">或输入图片URL:</label>
                    <input type="text" id="imageUrl" placeholder="Enter URL of an image to use as reference">
                </div>
            </div>
            
            

        </div>
        
        <div class="right-panel">
            <div class="result-area" id="resultArea" style="display: none;">
                <h2>问题解答</h2>
                <div id="textResult" class="text-result">
                    <div class="loading-indicator" id="textLoadingIndicator"></div>
                </div>
                <div id="imageLoadingMessage" class="image-loading">正在生成图像解答，请稍候...</div>
                <img id="resultImage" class="result-image" alt="解答图示将显示在这里">
                
                <!-- 添加对话区域 -->
                <div class="conversation-container" id="conversationContainer" style="display: none;">
                    <div class="conversation-messages" id="conversationMessages">
                        <!-- 对话消息将在这里动态添加 -->
                    </div>
                    <div class="conversation-input">
                        <input type="text" id="followupQuestion" placeholder="输入后续问题...">
                        <button id="sendFollowupBtn">继续提问</button>
                    </div>
                </div>
                
                <div>
                    <button id="saveBtn" style="display: none;">保存结果</button>
                    <button id="continueConversationBtn" style="display: none;">继续对话</button>
                </div>
            </div>

            <!-- 历史记录面板 -->
            <div class="history-panel">
                <div class="status-area" id="statusArea">
                    <div class="status-message">可直接生成图像。</div>
                </div>
                <div class="history-header">
                    <div class="history-toggle" id="historyToggle">历史记录</div>
                    <button class="history-clear" id="historyClear">清空历史</button>
                </div>
                <div class="history-content" id="historyContent">
                    <!-- 历史记录项将由JavaScript动态添加 -->
                    <div class="no-history">暂无历史记录</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 通知元素 -->
    <div id="notification" class="notification"></div>

    <script>
        // Model configurations
        const MODEL_CONFIGS = {
            "combined": {
                "sizes": ["1024x1024", "1024x1792", "1792x1024"],
                "api_endpoint": "chat/completions",
                "supports_image_input": true,
                "description": "同时生成文字和图像解答"
            },
            "claude-3-7-sonnet-20250219": {
                "sizes": ["1024x1024", "1024x1792", "1792x1024"],
                "api_endpoint": "chat/completions",
                "supports_image_input": true,
                "description": "文字解答(支持图片输入)"
            },
            "gpt-4o-image": {
                "sizes": ["1024x1024", "1024x1792", "1792x1024"],
                "api_endpoint": "chat/completions",
                "supports_image_input": true,
                "description": "仅提供图像解答"
            },
            "dall-e-3": {
                "sizes": ["1024x1024", "1024x1792", "1792x1024"],
                "api_endpoint": "images/generations",
                "supports_image_input": false,
                "description": "DALL-E 3图像模型"
            }
        };

        // DOM elements
        const apiKeyInput = document.getElementById('apiKey');
        const baseUrlInput = document.getElementById('baseUrl');
        const promptInput = document.getElementById('prompt');
        const modelSelect = document.getElementById('model');
        const sizeSelect = document.getElementById('size');
        const generateBtn = document.getElementById('generateBtn');
        const statusArea = document.getElementById('statusArea');
        const resultArea = document.getElementById('resultArea');
        const resultImage = document.getElementById('resultImage');
        const saveBtn = document.getElementById('saveBtn');
        const inputImageOptionsDiv = document.getElementById('inputImageOptions');
        const inputImageDiv = document.getElementById('inputImage');
        const imageUrlInput = document.getElementById('imageUrl');
        const pasteArea = document.getElementById('pasteArea');
        const pastePreview = document.getElementById('pastePreview');
        const historyToggle = document.getElementById('historyToggle');
        const historyContent = document.getElementById('historyContent');
        const historyClear = document.getElementById('historyClear');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const sendCanvasBtn = document.getElementById('sendCanvasBtn');
        const notification = document.getElementById('notification');
        const conversationContainer = document.getElementById('conversationContainer');
        const conversationMessages = document.getElementById('conversationMessages');
        const followupQuestion = document.getElementById('followupQuestion');
        const sendFollowupBtn = document.getElementById('sendFollowupBtn');
        const continueConversationBtn = document.getElementById('continueConversationBtn');

        // 存储当前对话历史
        let currentConversation = [];
        
        // 存储粘贴的图片数据
        let pastedImageData = null;
        
        // Canvas drawing functionality
        const ctx = drawingCanvas.getContext('2d');
        let drawing = false;
        let lastX = 0;
        let lastY = 0;
        let isEraser = false;
        let lastTime = 0;
        let lastSpeed = 0;
        const MIN_LINE_WIDTH = 0.5;
        const MAX_LINE_WIDTH = 16;
        let currentColor = '#000000'; // 当前选择的颜色

        // Initialize canvas
        function initializeCanvas() {
            drawingCanvas.width = drawingCanvas.offsetWidth;
            drawingCanvas.height = drawingCanvas.offsetHeight;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 2;
            ctx.strokeStyle = currentColor;
        }

        // Drawing functions
        function startDrawing(x, y) {
            drawing = true;
            [lastX, lastY] = [x, y];
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
        }

        function stopDrawing() {
            drawing = false;
        }

        function draw(x, y, pressure = 1) {
            if (!drawing) return;
            
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            if (isEraser) {
                // Calculate movement speed
                const currentTime = Date.now();
                const timeDiff = currentTime - lastTime;
                const distance = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
                const speed = timeDiff > 0 ? distance / timeDiff : 0;
                
                // Smooth speed changes
                lastSpeed = lastSpeed * 0.7 + speed * 0.3;
                
                const baseWidth = 20;
                const speedFactor = Math.min(lastSpeed * 2, 3);
                const pressureFactor = pressure > 0 ? pressure : 1;
                ctx.lineWidth = baseWidth * (speedFactor + pressureFactor);
                ctx.strokeStyle = '#ffffff';
                
                lastTime = currentTime;
            } else {
                ctx.strokeStyle = currentColor; // 使用当前选择的颜色
                ctx.lineWidth = pressure > 0 ? 
                    Math.min(MAX_LINE_WIDTH, Math.max(MIN_LINE_WIDTH, pressure * MAX_LINE_WIDTH)) : 2;
            }
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            [lastX, lastY] = [x, y];
        }

        // Canvas event listeners
        drawingCanvas.addEventListener('mousedown', (e) => {
            startDrawing(e.offsetX, e.offsetY);
        });

        drawingCanvas.addEventListener('mousemove', (e) => {
            draw(e.offsetX, e.offsetY);
        });

        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);

        // Add paste event listener to canvas
        drawingCanvas.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let blob = null;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') === 0) {
                    blob = items[i].getAsFile();
                    break;
                }
            }
            
            if (blob) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        // Clear canvas
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        
                        // Calculate dimensions to center the image
                        let width = img.width;
                        let height = img.height;
                        let x = 0;
                        let y = 0;
                        
                        // Scale image if needed
                        const maxWidth = drawingCanvas.width * 0.9; // 90% of canvas width
                        const maxHeight = drawingCanvas.height * 0.9; // 90% of canvas height
                        
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        
                        // Center image
                        x = (drawingCanvas.width - width) / 2;
                        y = (drawingCanvas.height - height) / 2;
                        
                        // Draw image on canvas
                        ctx.drawImage(img, x, y, width, height);
                        
                        showNotification('图片已粘贴到画布上并居中显示');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(blob);
            }
        });
        
        // Make canvas focusable so it can receive paste events
        drawingCanvas.setAttribute("tabindex", "0");
        drawingCanvas.addEventListener('click', function() {
            this.focus();
        });

        // Touch events
        drawingCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = drawingCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            startDrawing(x, y);
        });

        drawingCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = drawingCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            draw(x, y, touch.force || 1);
        });

        drawingCanvas.addEventListener('touchend', stopDrawing);
        drawingCanvas.addEventListener('touchcancel', stopDrawing);

        // Pointer events
        drawingCanvas.addEventListener('pointerdown', (e) => {
            if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
                e.preventDefault();
                if (e.buttons === 32 || isEraser) {
                    isEraser = true;
                    lastTime = Date.now();
                    lastSpeed = 0;
                }
                startDrawing(e.offsetX, e.offsetY);
            }
        });

        drawingCanvas.addEventListener('pointermove', (e) => {
            if (!drawing) return;
            e.preventDefault();
            draw(e.offsetX, e.offsetY, e.pressure);
        });

        drawingCanvas.addEventListener('pointerup', (e) => {
            stopDrawing();
            if (isEraser && !eraserBtn.classList.contains('active')) {
                isEraser = false;
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 2;
            }
        });

        drawingCanvas.addEventListener('pointerout', stopDrawing);
        drawingCanvas.addEventListener('pointercancel', stopDrawing);

        // Canvas button events
        clearCanvasBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            showNotification('画布已清除');
        });

        eraserBtn.addEventListener('click', () => {
            isEraser = !isEraser;
            
            if (isEraser) {
                ctx.strokeStyle = '#ffffff';
                drawingCanvas.style.cursor = 'not-allowed';
                showNotification('橡皮擦模式已启用');
                eraserBtn.classList.add('active');
            } else {
                ctx.strokeStyle = currentColor; // 恢复为当前选择的颜色
                drawingCanvas.style.cursor = 'crosshair';
                showNotification('绘图模式已启用');
                eraserBtn.classList.remove('active');
            }
        });

        sendCanvasBtn.addEventListener('click', () => {
            drawingCanvas.toBlob((blob) => {
                const reader = new FileReader();
                reader.onloadend = function() {
                    // Convert canvas to base64 image data
                    const base64data = reader.result;
                    
                    // Set this as the input image
                    pastedImageData = base64data;
                    
                    // Make sure we're using a model that supports image input
                    if (!MODEL_CONFIGS[modelSelect.value].supports_image_input) {
                        modelSelect.value = 'gpt-4o-image';
                        const event = new Event('change');
                        modelSelect.dispatchEvent(event);
                    }
                    
                    // Update UI to show the image is selected
                    pastePreview.src = base64data;
                    pastePreview.style.display = 'block';
                    inputImageOptionsDiv.style.display = 'block';
                    
                    showNotification('草图已准备好，可以生成图像了');
                    addStatus('草图已添加! 准备好生成图像了。');
                };
                reader.readAsDataURL(blob);
            });
        });

        // Notification function
        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = `notification show ${type}`;

            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // Window resize handler for canvas
        window.addEventListener('resize', () => {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = drawingCanvas.width;
            tempCanvas.height = drawingCanvas.height;
            tempCtx.drawImage(drawingCanvas, 0, 0);

            drawingCanvas.width = drawingCanvas.offsetWidth;
            drawingCanvas.height = drawingCanvas.offsetHeight;

            // Reinitialize canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 2;
            ctx.strokeStyle = currentColor;

            // Redraw previous content
            ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, drawingCanvas.width, drawingCanvas.height);
        });

        // 提示词分类和内容
        let promptsData = {};
        
        // 初始化提示词数据
        function initPromptsData() {
            promptsData = {
                'algebra': [
                    {value: '求解一元二次方程：ax² + bx + c = 0，其中a=1, b=5, c=6', label: '1. 一元二次方程'},
                    {value: '分解因式：x² - 9', label: '2. 多项式因式分解'},
                    {value: '简化表达式：(3x + 2)² - 4x(3x + 2) + 4x²', label: '3. 代数式化简'},
                    {value: '求解不等式：2x - 5 > 7', label: '4. 线性不等式'},
                    {value: '求函数f(x) = x² - 4x + 3的零点', label: '5. 函数零点'}
                ],
                'calculus': [
                    {value: '求函数f(x) = x³ - 3x² + 2的导数', label: '1. 求导数'},
                    {value: '计算定积分∫(0,1) x²dx', label: '2. 定积分计算'},
                    {value: '求曲线y = x² + 2x在点(1,3)处的切线方程', label: '3. 切线方程'},
                    {value: '判断级数Σ(n=1,∞) 1/n²是否收敛', label: '4. 级数收敛性'},
                    {value: '求函数f(x) = x²e^x的极值', label: '5. 函数极值'}
                ],
                'geometry': [
                    {value: '在三角形ABC中，角A=30°，角B=45°，边c=10，求三角形的面积', label: '1. 三角形面积'},
                    {value: '求圆(x-2)² + (y+1)² = 25的面积和周长', label: '2. 圆的面积周长'},
                    {value: '证明：三角形中位线平行于第三边且等于第三边的一半', label: '3. 三角形中位线'},
                    {value: '求两点A(1,2)和B(4,6)之间的距离', label: '4. 两点距离'},
                    {value: '求直线2x + 3y - 6 = 0与直线x - y + 2 = 0的交点', label: '5. 直线交点'}
                ],
                'trigonometry': [
                    {value: '验证恒等式：sin²θ + cos²θ = 1', label: '1. 三角恒等式'},
                    {value: '求解三角方程：2sinx + 1 = 0', label: '2. 三角方程'},
                    {value: '化简表达式：sin(x+π/4) + cos(x-π/4)', label: '3. 三角式化简'},
                    {value: '在三角形ABC中，a=4, b=5, c=6，求角A', label: '4. 三角形角度'},
                    {value: '证明：sin(2x) = 2sinx·cosx', label: '5. 倍角公式'}
                ],
                'statistics': [
                    {value: '计算数据集{2, 4, 6, 8, 10}的均值、中位数和标准差', label: '1. 描述统计'},
                    {value: '掷两个骰子，求和为7的概率', label: '2. 概率计算'},
                    {value: '若X~N(0,1)，求P(X<1.96)', label: '3. 正态分布'},
                    {value: '在袋子中有5个红球和3个蓝球，随机抽取2个球，求抽到2个红球的概率', label: '4. 组合概率'},
                    {value: '假设检验：样本均值为52，总体标准差为10，样本量为100，检验总体均值是否大于50', label: '5. 假设检验'}
                ],
                'number_theory': [
                    {value: '判断367是否为质数', label: '1. 质数判定'},
                    {value: '计算最大公约数：gcd(48, 36)', label: '2. 最大公约数'},
                    {value: '解同余方程：3x ≡ 5 (mod 7)', label: '3. 同余方程'},
                    {value: '找出100以内的所有完全数', label: '4. 完全数'},
                    {value: '使用欧拉函数计算φ(24)', label: '5. 欧拉函数'}
                ],
                'linear_algebra': [
                    {value: '计算行列式：|1 2 3; 4 5 6; 7 8 9|', label: '1. 行列式计算'},
                    {value: '解线性方程组：x + 2y = 5, 3x - y = 7', label: '2. 线性方程组'},
                    {value: '求矩阵A = [[1,2],[3,4]]的特征值和特征向量', label: '3. 特征值与特征向量'},
                    {value: '判断向量组{(1,0,1), (0,1,1), (1,1,0)}是否线性相关', label: '4. 线性相关性'},
                    {value: '将二次型x² + 4xy + y²化为标准形式', label: '5. 二次型化标准形'}
                ],
                'discrete_math': [
                    {value: '证明：对于所有自然数n，n³-n能被6整除', label: '1. 数论证明'},
                    {value: '计算组合数C(10,3)', label: '2. 组合计算'},
                    {value: '用归纳法证明：1+3+5+...+(2n-1) = n²', label: '3. 数学归纳法'},
                    {value: '求解递推关系：a_n = 3a_{n-1} - 2a_{n-2}，初始条件a_0 = 1, a_1 = 2', label: '4. 递推关系'},
                    {value: '证明：一个图的所有顶点的度数之和等于边数的两倍', label: '5. 图论证明'}
                ],
                'complex_analysis': [
                    {value: '计算复数z = 2 + 3i的模和辐角', label: '1. 复数运算'},
                    {value: '求函数f(z) = z²的复导数', label: '2. 复导数'},
                    {value: '计算积分∫|z|=1 (1/z²)dz', label: '3. 复变函数积分'},
                    {value: '求z = 2 + 3i的所有平方根', label: '4. 复数根'},
                    {value: '使用留数定理计算积分∫|z|=2 (1/(z-1))dz', label: '5. 留数计算'}
                ],
                'applied_math': [
                    {value: '一个物体从10米高处自由落下，求落地时间和速度', label: '1. 物理应用'},
                    {value: '100元以年利率5%复利存款，5年后本息合计多少？', label: '2. 金融计算'},
                    {value: '用欧拉法以步长h=0.1求解微分方程y\'=y，y(0)=1，求y(0.3)的近似值', label: '3. 数值方法'},
                    {value: 'A地到B地有3条路，B地到C地有4条路，从A地到C地共有多少种不同路线？', label: '4. 计数问题'},
                    {value: '已知商品需求函数p = 100 - 2q，求消费者剩余', label: '5. 经济应用'}
                ]
            };
        }
        
        // 显示子分类
        function showSubcategory() {
            const category = document.getElementById('promptCategory').value;
            const subcategoryContainer = document.getElementById('subcategoryContainer');
            const subcategorySelect = document.getElementById('promptSubcategory');
            
            // 清空现有选项，保留第一个默认选项
            subcategorySelect.innerHTML = '<option value="">-- 选择具体问题类型 --</option>';
            
            if (category && promptsData[category]) {
                // 填充子分类选项
                promptsData[category].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.value;
                    option.textContent = item.label;
                    subcategorySelect.appendChild(option);
                });
                
                // 显示子分类下拉框
                subcategoryContainer.style.display = 'block';
            } else {
                // 隐藏子分类下拉框
                subcategoryContainer.style.display = 'none';
            }
        }
        
        // 将选择的提示词添加到文本域
        function addPromptToTextarea() {
            const selectedPrompt = document.getElementById('promptSubcategory').value;
            if (selectedPrompt) {
                const promptTextarea = document.getElementById('prompt');
                // 检查当前文本是否为默认文本，如果是则清空
                if (promptTextarea.value === '求解方程：x² + 5x + 6 = 0') {
                    promptTextarea.value = selectedPrompt;
                } else {
                    // 否则在末尾添加新行
                    promptTextarea.value = promptTextarea.value.trim() + '\n' + selectedPrompt;
                }
                
                // 显示通知
                showNotification('已添加问题到输入框');
                addStatus(`已添加问题: "${selectedPrompt}"`);
            }
        }

        // Initialize the page
        window.onload = function() {
            // Initialize the canvas
            initializeCanvas();
            
            // Show initial paste hint
            addStatus('提示: 点击画布后可直接使用Ctrl+V粘贴图片到画布上');
            
            // 初始检查模型是否支持图像输入
            const supportsImage = MODEL_CONFIGS[modelSelect.value].supports_image_input;
            inputImageOptionsDiv.style.display = supportsImage ? 'block' : 'none';
            
            // 加载历史记录
            loadHistory();
            
            // 清除图片按钮事件处理
            const clearImageBtn = document.getElementById('clearImageBtn');
            clearImageBtn.addEventListener('click', function() {
                // 清除图片数据
                pastedImageData = null;
                pastePreview.src = '';
                pastePreview.style.display = 'none';
                imageUrlInput.value = '';
                
                // 显示通知
                showNotification('图片已清除');
                addStatus('已清除所有图片输入。');
            });
            
            // 初始化提示词数据
            initPromptsData();
            
            // 设置调色板功能
            initializeColorPalette();
            
            // 初始化对话界面
            continueConversationBtn.style.display = 'none';
            conversationContainer.style.display = 'none';
            
            // Update UI when model changes
            modelSelect.addEventListener('change', function() {
                const selectedModel = this.value;
                const modelConfig = MODEL_CONFIGS[selectedModel];
                const sizes = modelConfig.sizes;
                
                // Update size options
                sizeSelect.innerHTML = '';
                sizes.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size;
                    option.textContent = size;
                    sizeSelect.appendChild(option);
                });
                
                // Show/hide input image options based on model capability
                const supportsImage = modelConfig.supports_image_input;
                inputImageOptionsDiv.style.display = supportsImage ? 'block' : 'none';
                
                if (supportsImage) {
                    addStatus(`已切换到解答模式: ${modelConfig.description}。可以使用图像输入。`);
                } else {
                    addStatus(`已切换到解答模式: ${modelConfig.description}。该模式不支持图像输入。`, true);
                    // Clear any existing image data
                    pastedImageData = null;
                    pastePreview.style.display = 'none';
                }
            });
            
            // Handle paste events for the paste area
            pasteArea.addEventListener('click', function() {
                // Try to paste from clipboard
                navigator.clipboard.read().then(items => {
                    for (const item of items) {
                        if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                            item.getType('image/png').then(blob => {
                                const reader = new FileReader();
                                reader.onload = function(e) {
                                    pastedImageData = e.target.result;
                                    pastePreview.src = pastedImageData;
                                    pastePreview.style.display = 'block';
                                    
                                    // Clear URL input to avoid conflicts
                                    imageUrlInput.value = '';
                                    
                                    addStatus('图片已添加! 准备用于生成。');
                                };
                                reader.readAsDataURL(blob);
                            });
                        }
                    }
                }).catch(e => {
                    addStatus('请点击后使用Ctrl+V粘贴图片，或拖拽图片到此区域。');
                });
            });
            
            // Handle drag and drop
            pasteArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.style.borderColor = '#2a2a72';
                this.style.backgroundColor = '#f0f0f9';
            });
            
            pasteArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.style.borderColor = '#ccc';
                this.style.backgroundColor = '#f9f9f9';
            });
            
            pasteArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.style.borderColor = '#ccc';
                this.style.backgroundColor = '#f9f9f9';
                
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0 && files[0].type.indexOf('image') === 0) {
                    const file = files[0];
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        pastedImageData = e.target.result;
                        pastePreview.src = pastedImageData;
                        pastePreview.style.display = 'block';
                        
                        // Clear URL input to avoid conflicts
                        imageUrlInput.value = '';
                        
                        addStatus('图片已添加! 准备用于生成。');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Handle paste events globally
            document.addEventListener('paste', function(e) {
                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                let blob = null;
                
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') === 0) {
                        blob = items[i].getAsFile();
                        break;
                    }
                }
                
                if (blob && MODEL_CONFIGS[modelSelect.value].supports_image_input) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        pastedImageData = e.target.result;
                        pastePreview.src = pastedImageData;
                        pastePreview.style.display = 'block';
                        
                        // Clear URL input to avoid conflicts
                        imageUrlInput.value = '';
                        
                        addStatus('图片已添加! 准备用于生成。');
                    };
                    reader.readAsDataURL(blob);
                }
            });
        };

        // 历史记录相关函数
        function loadHistory() {
            const history = JSON.parse(localStorage.getItem('openai_image_history') || '[]');
            updateHistoryDisplay(history);
        }
        
        function saveToHistory(data) {
            const history = JSON.parse(localStorage.getItem('openai_image_history') || '[]');
            // 将新的记录添加到顶部
            history.unshift(data);
            // 只保留最近的30条记录
            if (history.length > 30) {
                history.pop();
            }
            localStorage.setItem('openai_image_history', JSON.stringify(history));
            updateHistoryDisplay(history);
        }
        
        function updateHistoryDisplay(history) {
            historyContent.innerHTML = '';
            
            if (history.length === 0) {
                const noHistory = document.createElement('div');
                noHistory.className = 'no-history';
                noHistory.textContent = '暂无历史记录';
                historyContent.appendChild(noHistory);
                return;
            }
            
            history.forEach((item, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                // 创建图片元素
                const imgContainer = document.createElement('div');
                imgContainer.className = 'history-img-container';
                
                const img = document.createElement('img');
                img.className = 'history-img';
                
                if (item.imageUrl) {
                    img.src = item.imageUrl;
                    img.alt = `解答图示 ${index + 1}`;
                } else {
                    // 如果没有图片，显示文字预览
                    img.src = 'data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22200%22%20height%3D%22150%22%3E%3Crect%20fill%3D%22%23ddd%22%20width%3D%22200%22%20height%3D%22150%22%2F%3E%3Ctext%20fill%3D%22%23666%22%20font-family%3D%22sans-serif%22%20font-size%3D%2214%22%20x%3D%2250%25%22%20y%3D%2250%25%22%20text-anchor%3D%22middle%22%3E%E6%96%87%E5%AD%97%E8%A7%A3%E7%AD%94%3C%2Ftext%3E%3C%2Fsvg%3E';
                    img.alt = `仅文字解答 ${index + 1}`;
                }
                
                // 显示答案类型标签
                const typeLabel = document.createElement('div');
                typeLabel.className = 'history-type-label';
                
                if (item.textResponse && item.imageUrl) {
                    typeLabel.textContent = '文字+图像';
                    typeLabel.className += ' combined-label';
                } else if (item.imageUrl) {
                    typeLabel.textContent = '图像';
                    typeLabel.className += ' image-label';
                } else if (item.textResponse) {
                    typeLabel.textContent = '文字';
                    typeLabel.className += ' text-label';
                }
                
                imgContainer.appendChild(img);
                imgContainer.appendChild(typeLabel);
                
                // 点击事件
                historyItem.onclick = () => {
                    // 准备显示结果区域
                    resultArea.style.display = 'block';

                    // 重置显示内容
                    document.getElementById('textResult').innerHTML = '';
                    document.getElementById('resultImage').style.display = 'none';
                    document.getElementById('imageLoadingMessage').style.display = 'none';
                    
                    // 显示文字答案
                    if (item.textResponse) {
                        const textResult = document.getElementById('textResult');
                        textResult.style.display = 'block';
                        
                        // 创建一个新的容器元素
                        const responseContainer = document.createElement('div');
                        responseContainer.innerHTML = item.textResponse;
                        textResult.appendChild(responseContainer);
                        
                        // 处理可能包含的SVG内容
                        processSvgContent(responseContainer);
                        
                        // 渲染数学公式
                        setTimeout(() => {
                            if (window.MathJax) {
                                window.MathJax.typeset();
                            }
                        }, 100);
                    } else {
                        document.getElementById('textResult').style.display = 'none';
                    }
                    
                    // 显示图片答案
                    if (item.imageUrl) {
                        const resultImage = document.getElementById('resultImage');
                        resultImage.src = item.imageUrl;
                        resultImage.style.display = 'block';
                    }
                };
                
                // 创建信息区域
                const infoDiv = document.createElement('div');
                infoDiv.className = 'history-info';
                
                // 创建提示词显示
                const promptP = document.createElement('p');
                promptP.className = 'history-prompt';
                promptP.title = item.prompt;
                promptP.textContent = item.prompt;
                
                // 创建日期显示
                const dateP = document.createElement('p');
                dateP.className = 'history-date';
                dateP.textContent = new Date(item.timestamp).toLocaleString();
                
                // 创建操作按钮区域
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'history-actions';
                
                // 创建删除按钮
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'history-action-btn';
                deleteBtn.innerHTML = '&#x2715;'; // ×符号
                deleteBtn.title = '删除';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeHistoryItem(index);
                };
                
                // 创建使用提示词按钮
                const usePromptBtn = document.createElement('div');
                usePromptBtn.className = 'history-action-btn';
                usePromptBtn.innerHTML = '&#x270E;'; // 铅笔符号
                usePromptBtn.title = '使用此问题';
                usePromptBtn.onclick = (e) => {
                    e.stopPropagation();
                    promptInput.value = item.prompt;
                    addStatus(`已加载问题: "${item.prompt}"`);
                };
                
                // 组装各个元素
                actionsDiv.appendChild(usePromptBtn);
                actionsDiv.appendChild(deleteBtn);
                
                infoDiv.appendChild(promptP);
                infoDiv.appendChild(dateP);
                
                historyItem.appendChild(imgContainer);
                historyItem.appendChild(infoDiv);
                historyItem.appendChild(actionsDiv);
                
                historyContent.appendChild(historyItem);
            });
        }
        
        function removeHistoryItem(index) {
            const history = JSON.parse(localStorage.getItem('openai_image_history') || '[]');
            history.splice(index, 1);
            localStorage.setItem('openai_image_history', JSON.stringify(history));
            updateHistoryDisplay(history);
        }
        
        // 处理历史记录面板的折叠与展开
        historyToggle.addEventListener('click', function() {
            this.classList.toggle('collapsed');
            historyContent.classList.toggle('collapsed');
        });
        
        // 处理清空历史记录
        historyClear.addEventListener('click', function() {
            if (confirm('确定要清空所有历史记录吗？此操作不可恢复。')) {
                localStorage.removeItem('openai_image_history');
                updateHistoryDisplay([]);
                addStatus('历史记录已清空');
            }
        });

        // 初始化调色板功能
        function initializeColorPalette() {
            const colorOptions = document.querySelectorAll('.color-option');
            const customColorPicker = document.getElementById('customColorPicker');
            
            // 为每个颜色选项添加点击事件
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    // 移除所有active类
                    colorOptions.forEach(opt => opt.classList.remove('active'));
                    // 给当前选中的添加active类
                    this.classList.add('active');
                    // 更新当前颜色
                    currentColor = this.getAttribute('data-color');
                    // 同步更新自定义颜色选择器的值
                    customColorPicker.value = currentColor;
                    // 如果不是橡皮擦模式，更新绘图颜色
                    if (!isEraser) {
                        ctx.strokeStyle = currentColor;
                    }
                    showNotification(`颜色已切换为: ${currentColor}`);
                });
            });
            
            // 为自定义颜色选择器添加事件
            customColorPicker.addEventListener('input', function() {
                // 更新当前颜色
                currentColor = this.value;
                // 移除所有active类
                colorOptions.forEach(opt => opt.classList.remove('active'));
                // 如果不是橡皮擦模式，更新绘图颜色
                if (!isEraser) {
                    ctx.strokeStyle = currentColor;
                }
                showNotification(`自定义颜色: ${currentColor}`);
            });
        }

        // Add status message
        function addStatus(message, isError = false) {
            const statusMessage = document.createElement('div');
            statusMessage.className = isError ? 'status-message error-message' : 'status-message';
            statusMessage.textContent = message;
            statusArea.appendChild(statusMessage);
            statusArea.scrollTop = statusArea.scrollHeight;
        }

        // Generate image with DALL-E 3
        async function generateDallE3Image(apiKey, baseUrl, prompt, size) {
            try {
                const endpoint = `${baseUrl.replace(/\/$/, '')}/images/generations`;
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        n: 1,
                        model: 'dall-e-3',
                        size: size
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    return {
                        success: false,
                        error: errorData.error?.message || `API error: ${response.status} ${response.statusText}`
                    };
                }
                
                const data = await response.json();
                if (data.data && data.data.length > 0 && data.data[0].url) {
                    return {
                        success: true,
                        imageUrl: data.data[0].url
                    };
                } else {
                    return {
                        success: false,
                        error: 'No image URL found in response'
                    };
                }
            } catch (error) {
                console.error('Error generating DALL-E image:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Generate image with GPT-4o focusing on graphical content
        async function generateGPT4oImage(apiKey, baseUrl, prompt, size, imageUrl = null) {
            try {
                // 显示图像加载消息
                document.getElementById('imageLoadingMessage').style.display = 'block';
                document.getElementById('resultImage').style.display = 'none';
                
                const endpoint = `${baseUrl.replace(/\/$/, '')}/chat/completions`;
                
                // 优化提示词，专注于图形内容
                const enhancedPrompt = `请为以下数学问题创建一个清晰的图形解答：${prompt}
                
重要提示：
1. 专注于绘制文字难以清晰描述的图形内容，如几何图形、坐标系、函数图像、矢量图等
2. 使用适当的数学符号和标注，确保图形清晰可读
3. 若问题需要多步解答，可以创建多个小图展示解题过程
4. 避免在图中重复大段文字解释，文字解释会单独提供
5. 保持图形简洁、专业，使用合适的颜色和标注`;

                // Prepare messages content
                const messagesContent = [
                    {
                        "type": "text",
                        "text": enhancedPrompt
                    }
                ];
                
                // Add image to content if URL is provided
                if (imageUrl) {
                    // 检查是否为Base64图片数据
                    if (imageUrl.startsWith('data:image')) {
                        addStatus(`使用上传的图片作为参考进行解答...`);
                        messagesContent.push({
                            "type": "image_url",
                            "image_url": {
                                "url": imageUrl
                            }
                        });
                    } else {
                        addStatus(`使用图片URL作为参考进行解答: ${imageUrl}`);
                        messagesContent.push({
                            "type": "image_url",
                            "image_url": {
                                "url": imageUrl
                            }
                        });
                    }
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-image',
                        messages: [
                            {
                                "role": "user",
                                "content": messagesContent
                            }
                        ],
                        max_tokens: 500
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    document.getElementById('imageLoadingMessage').style.display = 'none';
                    return {
                        success: false,
                        error: errorData.error?.message || `API error: ${response.status} ${response.statusText}`
                    };
                }
                
                const data = await response.json();
                
                // 隐藏加载消息
                document.getElementById('imageLoadingMessage').style.display = 'none';
                
                if (data.choices && data.choices.length > 0) {
                    const responseContent = data.choices[0].message.content;
                    
                    // Extract image URL from the markdown response
                    const imageUrlMatch = responseContent.match(/!\[.*?\]\((https:\/\/[^\s\)]+)\)/);
                    
                    if (imageUrlMatch) {
                        const imageUrl = imageUrlMatch[1];
                        addStatus(`图片解答已生成`);
                        
                        // 显示图片
                        document.getElementById('resultImage').style.display = 'block';
                        
                        return {
                            success: true,
                            imageUrl: imageUrl
                        };
                    } else {
                        // Try alternative format
                        const downloadLinkMatch = responseContent.match(/\[点击下载\]\((https:\/\/[^\s\)]+)\)/);
                        if (downloadLinkMatch) {
                            const imageUrl = downloadLinkMatch[1];
                            addStatus(`图片解答已生成`);
                            
                            // 显示图片
                            document.getElementById('resultImage').style.display = 'block';
                            
                            return {
                                success: true,
                                imageUrl: imageUrl
                            };
                        } else {
                            return {
                                success: false,
                                error: `无法从响应中提取图片URL: ${responseContent.substring(0, 100)}...`
                            };
                        }
                    }
                } else {
                    return {
                        success: false,
                        error: '从GPT-4o响应中未找到图片信息'
                    };
                }
            } catch (error) {
                console.error('Error generating GPT-4o image:', error);
                document.getElementById('imageLoadingMessage').style.display = 'none';
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Generate text response with GPT-4.1 with streaming
        async function generateGPT41TextResponse(apiKey, baseUrl, prompt, imageUrl = null, withHistory = false) {
            try {
                // 清空文本结果区域
                const textResult = document.getElementById('textResult');
                textResult.innerHTML = '<div class="loading-indicator" id="textLoadingIndicator"></div>';
                document.getElementById('textLoadingIndicator').style.display = 'block';
                
                // 显示结果区域
                document.getElementById('resultArea').style.display = 'block';
                
                const endpoint = `${baseUrl.replace(/\/$/, '')}/chat/completions`;
                
                // 准备消息内容
                let messages = [];
                
                if (withHistory && currentConversation.length > 0) {
                    // 使用完整对话历史
                    messages = currentConversation.map(msg => ({
                        role: msg.role,
                        content: typeof msg.content === 'string' 
                            ? [{ type: "text", text: msg.content }] 
                            : msg.content
                    }));
                } else {
                    // 新对话，仅用当前提示
                    messages = [{
                        role: "user",
                        content: [{
                            type: "text",
                            text: `解答以下数学问题，请给出清晰的步骤和解释。主要聚焦于公式推导、计算和理论解释。
                            
必要时，你可以使用SVG图表来表示关键概念或解题步骤。特别是对于以下内容：
1. 几何图形和空间关系
2. 坐标系和函数图像
3. svg的y值和坐标系的y值是相反的
4. 统计数据和分布
5. 向量和力的分解
6. 流程图和树形结构

请确保：
- 使用SVG格式而非ASCII图表来展示复杂图形
- 使用不同颜色提高图表可读性
- 为SVG添加合适的宽高和视口设置
- 包含必要的标签和图例

问题：${prompt}`
                        }]
                    }];
                    
                    // 初始化新的对话历史
                    currentConversation = [{
                        role: 'user',
                        content: prompt
                    }];
                }
                
                // 如果提供了图片，添加到第一条消息的内容中
                if (imageUrl && messages.length > 0) {
                    // 检查是否为Base64图片数据
                    if (imageUrl.startsWith('data:image')) {
                        addStatus(`使用上传的图片作为参考生成文字解答...`);
                        // 图片添加到第一条消息
                        if (typeof messages[0].content === 'string') {
                            messages[0].content = [
                                { type: "text", text: messages[0].content },
                                { type: "image_url", image_url: { url: imageUrl } }
                            ];
                        } else {
                            messages[0].content.push({ 
                                type: "image_url", 
                                image_url: { url: imageUrl } 
                            });
                        }
                    } else {
                        addStatus(`使用URL图片作为参考生成文字解答: ${imageUrl}`);
                        // 图片添加到第一条消息
                        if (typeof messages[0].content === 'string') {
                            messages[0].content = [
                                { type: "text", text: messages[0].content },
                                { type: "image_url", image_url: { url: imageUrl } }
                            ];
                        } else {
                            messages[0].content.push({ 
                                type: "image_url", 
                                image_url: { url: imageUrl } 
                            });
                        }
                    }
                }
                
                // 创建流式请求
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-7-sonnet-20250219',
                        messages: messages,
                        stream: true,
                        max_tokens: 10000
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    document.getElementById('textLoadingIndicator').style.display = 'none';
                    return {
                        success: false,
                        error: errorData.error?.message || `API error: ${response.status} ${response.statusText}`
                    };
                }
                
                // 处理流式响应
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let accumulatedResponse = '';
                let buffer = '';
                
                // 创建存储响应的元素
                const responseContainer = document.createElement('div');
                textResult.appendChild(responseContainer);
                
                // 流式读取响应
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    // 解码新接收的数据
                    buffer += decoder.decode(value, { stream: true });
                    
                    // 处理缓冲区中完整的数据行
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // 保留最后一个不完整的行
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        if (line.trim() === 'data: [DONE]') continue;
                        
                        let data;
                        try {
                            // 提取JSON部分
                            const jsonStr = line.replace(/^data: /, '');
                            data = JSON.parse(jsonStr);
                        } catch (error) {
                            console.warn('Failed to parse JSON from line:', line, error);
                            continue;
                        }
                        
                        // 提取文本内容
                        if (data.choices && data.choices.length > 0) {
                            const delta = data.choices[0].delta;
                            if (delta && delta.content) {
                                accumulatedResponse += delta.content;
                                
                                // 安全地设置HTML内容
                                responseContainer.innerHTML = accumulatedResponse;
                                
                                // 尝试解析和处理可能的SVG内容
                                processSvgContent(responseContainer);
                                
                                // 添加MathJax处理
                                try {
                                    if (window.MathJax) {
                                        window.MathJax.typesetPromise([responseContainer]).catch(err => console.log('MathJax error:', err));
                                    }
                                } catch (err) {
                                    console.log('MathJax processing error:', err);
                                }
                                
                                // 滚动到底部
                                textResult.scrollTop = textResult.scrollHeight;
                            }
                        }
                    }
                }
                
                // 隐藏加载指示器
                document.getElementById('textLoadingIndicator').style.display = 'none';
                
                // 确保SVG内容被正确处理
                processSvgContent(responseContainer);
                
                // 添加assistant回应到对话历史
                currentConversation.push({
                    role: 'assistant',
                    content: accumulatedResponse
                });
                
                // 显示继续对话按钮
                continueConversationBtn.style.display = 'inline-block';
                
                return {
                    success: true,
                    textResponse: accumulatedResponse
                };
            } catch (error) {
                console.error('Error generating text response:', error);
                document.getElementById('textLoadingIndicator').style.display = 'none';
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // 处理可能包含的SVG内容
        function processSvgContent(container) {
            // 查找所有代码块，检查是否包含SVG
            const codeBlocks = container.querySelectorAll('pre');
            codeBlocks.forEach(block => {
                const content = block.textContent;
                if (content.trim().startsWith('<svg') && content.includes('</svg>')) {
                    try {
                        // 创建一个新的div来放置SVG
                        const svgContainer = document.createElement('div');
                        svgContainer.classList.add('svg-container');
                        svgContainer.innerHTML = content;
                        
                        // 替换代码块为SVG显示
                        block.parentNode.replaceChild(svgContainer, block);
                    } catch (err) {
                        console.error('Error processing SVG:', err);
                    }
                }
            });
            
            // 检查直接包含在回答中的SVG标签
            const content = container.innerHTML;
            const svgRegex = /<svg[\s\S]*?<\/svg>/g;
            const matches = content.match(svgRegex);
            
            if (matches) {
                // 确保所有SVG都有正确的尺寸和样式
                matches.forEach(svgStr => {
                    // 只处理尚未处理过的SVG
                    if (!svgStr.includes('class="processed-svg"')) {
                        const processedSvg = svgStr
                            .replace(/<svg/, '<svg class="processed-svg" style="max-width:100%; height:auto;"')
                            .replace(/width="(\d+)"/, 'width="100%"');
                        
                        container.innerHTML = container.innerHTML.replace(svgStr, processedSvg);
                    }
                });
            }
        }

        // 继续对话按钮事件处理
        continueConversationBtn.addEventListener('click', function() {
            // 显示对话容器
            conversationContainer.style.display = 'flex';
            
            // 如果对话历史为空，添加初始消息
            if (conversationMessages.children.length === 0 && currentConversation.length > 0) {
                // 添加已有的对话到对话容器
                currentConversation.forEach(msg => {
                    addConversationMessage(
                        msg.content.type === 'text' ? msg.content : 
                        typeof msg.content === 'string' ? msg.content : 
                        msg.content[0]?.text || '图片输入',
                        msg.role
                    );
                });
            }
            
            // 设置焦点到输入框
            followupQuestion.focus();
        });
        
        // 添加生成图像按钮的事件监听器
        generateBtn.addEventListener('click', async function() {
            const apiKey = apiKeyInput.value.trim();
            const baseUrl = baseUrlInput.value.trim();
            const promptText = promptInput.value.trim();
            const model = modelSelect.value;
            const size = sizeSelect.value;
            const imageUrl = imageUrlInput.value.trim();
            
            if (!promptText) {
                addStatus('请输入问题描述。', true);
                return;
            }
            
            // 如果没有上传图片，自动从画布中获取
            if (!pastedImageData && !imageUrl) {
                // 检查画布是否为空白
                const blankCanvas = document.createElement('canvas');
                blankCanvas.width = drawingCanvas.width;
                blankCanvas.height = drawingCanvas.height;
                const blankCtx = blankCanvas.getContext('2d');
                blankCtx.fillStyle = '#ffffff';
                blankCtx.fillRect(0, 0, blankCanvas.width, blankCanvas.height);
                
                // 比较当前画布与空白画布是否不同
                const currentImageData = ctx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height).data;
                const blankImageData = blankCtx.getImageData(0, 0, blankCanvas.width, blankCanvas.height).data;
                
                let isDifferent = false;
                for (let i = 0; i < currentImageData.length; i += 4) {
                    if (currentImageData[i] !== blankImageData[i] || 
                        currentImageData[i+1] !== blankImageData[i+1] || 
                        currentImageData[i+2] !== blankImageData[i+2] || 
                        currentImageData[i+3] !== blankImageData[i+3]) {
                        isDifferent = true;
                        break;
                    }
                }
                
                // 如果画布不是空白的，自动上传图片
                if (isDifferent) {
                    addStatus('自动从画布获取图片...');
                    drawingCanvas.toBlob((blob) => {
                        const reader = new FileReader();
                        reader.onloadend = function() {
                            pastedImageData = reader.result;
                            // 确保我们使用支持图像输入的模型
                            if (!MODEL_CONFIGS[model].supports_image_input) {
                                modelSelect.value = 'gpt-4o-image';
                                const event = new Event('change');
                                modelSelect.dispatchEvent(event);
                            }
                            
                            // 继续生成过程
                            continueGeneration();
                        };
                        reader.readAsDataURL(blob);
                    });
                    return; // 等待图片处理完成后再继续
                }
            }
            
            // 直接继续生成过程
            continueGeneration();
            
            // 继续生成过程的函数
            async function continueGeneration() {
                // 按行分割提示词
                const prompts = promptText.split('\n').filter(p => p.trim().length > 0);
                
                if (prompts.length === 0) {
                    addStatus('没有有效的问题描述。', true);
                    return;
                }
                
                // Disable button during generation
                generateBtn.disabled = true;
                
                // 创建批量处理进度显示
                const batchProgressDiv = document.createElement('div');
                batchProgressDiv.className = 'batch-progress';
                
                const progressTitle = document.createElement('div');
                const totalCount = prompts.length;
                progressTitle.innerHTML = `<strong>问题解答进度</strong>: 0/${totalCount} 完成`;
                
                const progressBarContainer = document.createElement('div');
                progressBarContainer.className = 'progress-bar-container';
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                progressBar.style.width = '0%';
                
                progressBarContainer.appendChild(progressBar);
                batchProgressDiv.appendChild(progressTitle);
                batchProgressDiv.appendChild(progressBarContainer);
                
                statusArea.appendChild(batchProgressDiv);
                addStatus(`开始解答 ${totalCount} 个问题...`);
                
                // 存储所有成功生成的答案
                const generatedResults = [];
                
                try {
                    for (let i = 0; i < prompts.length; i++) {
                        const prompt = prompts[i].trim();
                        if (prompt.length === 0) continue;
                        
                        // 更新进度显示
                        progressTitle.innerHTML = `<strong>问题解答进度</strong>: ${i}/${totalCount} 完成`;
                        progressBar.style.width = `${(i / totalCount) * 100}%`;
                        
                        addStatus(`[${i+1}/${totalCount}] 正在解答: "${prompt}" 使用模式: ${MODEL_CONFIGS[model].description}`);
                        
                        // 结果对象
                        let result = {
                            prompt: prompt,
                            timestamp: Date.now(),
                            model: model,
                            textResponse: null,
                            imageUrl: null
                        };
                        
                        // 为combined和文字模式先生成文字回答
                        if (model === 'combined' || model === 'claude-3-7-sonnet-20250219') {
                            // 准备图片输入
                            let inputImageUrl = null;
                            if (pastedImageData && pastedImageData.startsWith('data:image')) {
                                inputImageUrl = pastedImageData;
                                addStatus(`[${i+1}/${totalCount}] 使用上传的图片作为输入生成文字解答...`);
                            } else if (imageUrl) {
                                inputImageUrl = imageUrl;
                                addStatus(`[${i+1}/${totalCount}] 使用URL图片作为输入生成文字解答...`);
                            }
                            
                            // 生成文字回答(流式)
                            const textResponse = await generateGPT41TextResponse(apiKey, baseUrl, prompt, inputImageUrl);
                            
                            if (textResponse.success) {
                                addStatus(`[${i+1}/${totalCount}] 文字解答生成成功!`);
                                result.textResponse = textResponse.textResponse;
                            } else {
                                addStatus(`[${i+1}/${totalCount}] 文字解答生成错误: ${textResponse.error}`, true);
                            }
                        }
                        
                        // 根据模式生成图片
                        if (model === 'combined' || model === 'gpt-4o-image') {
                            // 生成图像答案
                            let imageResponse;
                            
                            if (pastedImageData && pastedImageData.startsWith('data:image')) {
                                addStatus(`[${i+1}/${totalCount}] 使用上传的图片作为输入生成图形解答...`);
                                imageResponse = await generateGPT4oImage(apiKey, baseUrl, prompt, size, pastedImageData);
                            } else if (imageUrl) {
                                addStatus(`[${i+1}/${totalCount}] 使用URL图片作为输入生成图形解答...`);
                                imageResponse = await generateGPT4oImage(apiKey, baseUrl, prompt, size, imageUrl);
                            } else {
                                addStatus(`[${i+1}/${totalCount}] 根据文本描述生成图形解答...`);
                                imageResponse = await generateGPT4oImage(apiKey, baseUrl, prompt, size);
                            }
                            
                            if (imageResponse.success) {
                                addStatus(`[${i+1}/${totalCount}] 图形解答生成成功!`);
                                result.imageUrl = imageResponse.imageUrl;
                                
                                // 显示图片
                                resultImage.src = imageResponse.imageUrl;
                            } else {
                                addStatus(`[${i+1}/${totalCount}] 图形解答生成错误: ${imageResponse.error}`, true);
                            }
                        }
                        
                        // 添加到结果列表并保存到历史记录
                        if (result.textResponse || result.imageUrl) {
                            generatedResults.push(result);
                            saveToHistory(result);
                        }
                    }
                    
                    // 完成所有生成
                    progressTitle.innerHTML = `<strong>问题解答进度</strong>: ${totalCount}/${totalCount} 完成`;
                    progressBar.style.width = '100%';
                    
                    // 显示结果摘要
                    if (generatedResults.length > 0) {
                        addStatus(`问题解答完成！成功解答 ${generatedResults.length}/${totalCount} 个问题。`);
                        
                        // 显示最后一个生成的答案
                        const lastResult = generatedResults[generatedResults.length - 1];
                        
                        if (lastResult.textResponse) {
                            document.getElementById('textResult').innerHTML = lastResult.textResponse;
                            
                            // 渲染数学公式
                            setTimeout(() => {
                                if (window.MathJax) {
                                    window.MathJax.typeset();
                                }
                            }, 100);
                        }
                        
                        if (lastResult.imageUrl) {
                            resultImage.src = lastResult.imageUrl;
                            resultImage.style.display = 'block';
                        } else {
                            resultImage.style.display = 'none';
                        }
                        
                        // 确保结果区域是显示的
                        resultArea.style.display = 'block';
                        // 根据是否有内容展示保存按钮
                        saveBtn.style.display = (lastResult.textResponse || lastResult.imageUrl) ? 'inline-block' : 'none';
                        
                        // Set up save button for last generated answer
                        saveBtn.onclick = function() {
                            // Instead of creating HTML, just save the image if available
                            if (lastResult.imageUrl) {
                                const a = document.createElement('a');
                                a.href = lastResult.imageUrl;
                                a.download = `math_solution_image_${new Date().getTime()}.png`;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                            }
                            
                            // Create a text file with the solution
                            if (lastResult.textResponse) {
                                const blob = new Blob([lastResult.prompt + "\n\n" + lastResult.textResponse], {type: 'text/plain'});
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `math_solution_text_${new Date().getTime()}.txt`;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                            }
                        };
                    } else {
                        addStatus('解答完成，但没有成功生成任何答案。', true);
                    }
                } catch (error) {
                    addStatus(`生成答案过程中发生错误: ${error.message}`, true);
                    console.error(error);
                } finally {
                    generateBtn.disabled = false;
                }
            }
        });

        // 添加对话历史和继续对话的JavaScript代码
        sendFollowupBtn.addEventListener('click', async function() {
            await sendFollowupQuestion();
        });
        
        // 支持Enter键发送问题
        followupQuestion.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // 阻止默认行为
                sendFollowupBtn.click(); // 触发发送按钮点击
            }
        });
        
        // 发送后续问题的函数
        async function sendFollowupQuestion() {
            const followupQuestionText = followupQuestion.value.trim();
            if (followupQuestionText) {
                // 添加用户问题到对话历史
                currentConversation.push({
                    role: 'user',
                    content: followupQuestionText
                });
                // 在UI中添加消息
                addConversationMessage(followupQuestionText, 'user');
                followupQuestion.value = '';
                
                // 禁用按钮，显示加载状态
                sendFollowupBtn.disabled = true;
                let tempMessageDiv = document.createElement('div');
                tempMessageDiv.className = 'message assistant-message';
                tempMessageDiv.innerHTML = '<p>正在思考...</p>';
                conversationMessages.appendChild(tempMessageDiv);
                conversationMessages.scrollTop = conversationMessages.scrollHeight;
                
                // 发送请求
                try {
                    const response = await fetch(`${baseUrlInput.value.replace(/\/$/, '')}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKeyInput.value}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-7-sonnet-20250219',
                            messages: currentConversation.map(msg => ({
                                role: msg.role,
                                content: typeof msg.content === 'string' ? msg.content : msg.content
                            })),
                            stream: false,
                            max_tokens: 10000
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const assistantResponse = data.choices[0].message.content;
                    
                    // 添加助手回应到对话历史
                    currentConversation.push({
                        role: 'assistant',
                        content: assistantResponse
                    });
                    
                    // 移除临时消息
                    conversationMessages.removeChild(tempMessageDiv);
                    
                    // 添加真实回应
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'message assistant-message';
                    const messageContent = document.createElement('div');
                    messageContent.innerHTML = assistantResponse;
                    
                    // 处理SVG内容
                    processSvgContent(messageContent);
                    
                    messageDiv.appendChild(messageContent);
                    messageDiv.innerHTML += `<span class="message-time">${new Date().toLocaleTimeString()}</span>`;
                    conversationMessages.appendChild(messageDiv);
                    
                    // 处理MathJax
                    if (window.MathJax) {
                        window.MathJax.typesetPromise([messageDiv]).catch(err => console.log('MathJax error:', err));
                    }
                    
                    // 滚动到最新消息
                    conversationMessages.scrollTop = conversationMessages.scrollHeight;
                    
                    // 记录状态
                    addStatus('回复已生成');
                    
                } catch (error) {
                    console.error('Error in conversation:', error);
                    // 显示错误消息
                    conversationMessages.removeChild(tempMessageDiv);
                    addConversationMessage(`回答生成失败: ${error.message}`, 'assistant');
                    addStatus(`生成答案时发生错误: ${error.message}`, true);
                } finally {
                    // 重新启用按钮
                    sendFollowupBtn.disabled = false;
                }
            }
        }

        function addConversationMessage(message, role) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.classList.add(role === 'user' ? 'user-message' : 'assistant-message');
            messageDiv.innerHTML = '<p>' + message + '</p><span class="message-time">' + new Date().toLocaleTimeString() + '</span>';
            conversationMessages.appendChild(messageDiv);
            conversationMessages.scrollTop = conversationMessages.scrollHeight;
        }
    </script>
</body>
</html> 