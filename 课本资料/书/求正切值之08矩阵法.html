<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>求解 tan∠BAC之08矩阵法</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        .example {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .coordinate-system {
            margin: 20px 0;
            background: white;
        }
        .controls {
            margin: 20px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 5px;
        }
        .controls label {
            margin-right: 10px;
        }
        .controls input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        .controls span {
            margin-left: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h2>矩阵法</h2>
    
    <div class="example">
        <h3>例题</h3>
        <p><strong>题目：</strong>如图所示，在坐标系中有两个正交向量\(\vec{u}=(6,1)\)和\(\vec{v}=(-1,6)\)。求矩阵\(\begin{bmatrix} 6 & 1 \\ -1 & 6 \end{bmatrix}\)乘以向量\((3,6)\)得到的结果，并求这个结果向量的两个分量之比。</p>
        
        <p><strong>解：</strong></p>
        <p>\[\begin{bmatrix} 6 & 1 \\ -1 & 6 \end{bmatrix} \begin{bmatrix} 3 \\ 6 \end{bmatrix} = \begin{bmatrix} 6 \cdot 3 + 1 \cdot 6 \\ -1 \cdot 3 + 6 \cdot 6 \end{bmatrix} = \begin{bmatrix} 18 + 6 \\ -3 + 36 \end{bmatrix} = \begin{bmatrix} 24 \\ 33 \end{bmatrix}\]</p>
        <p>两个分量之比为：\(\frac{24}{33} = \frac{8}{11}\)</p>
        
        <div class="controls">
            <label for="scale">缩放: </label>
            <input type="range" id="scale" min="10" max="50" value="25" step="1">
            <span id="scaleValue">25</span>
        </div>
        
        <svg id="coordinate-system" width="800" height="600"></svg>

        <script>
            // 设置中心点和缩放比例
            const svgWidth = 800;  
            const svgHeight = 600;
            const centerX = svgWidth / 2;
            const centerY = svgHeight / 2;
            let scale = 25; // 每个单位对应的像素数
            
            // 坐标点（数学坐标系中）
            const pointA = {x: 0, y: 0};
            const pointB = {x: 6, y: 1};
            const pointC = {x: 3, y: 6};
            const pointD = {x: -1, y: 6};
            
            // 转换为SVG坐标
            function toSvgX(x) {
                return centerX + x * scale;
            }
            
            function toSvgY(y) {
                // SVG中y轴朝下为正，所以需要反转
                return centerY - y * scale;
            }
            
            // 创建SVG元素
            function createSVGElement(tag) {
                return document.createElementNS("http://www.w3.org/2000/svg", tag);
            }
            
            // 绘制坐标系和图形
            function drawCoordinateSystem() {
                const svg = document.getElementById('coordinate-system');
                svg.innerHTML = ''; // 清空已有内容
                
                // 计算可见范围（单位）
                const visibleWidth = svgWidth / scale;
                const visibleHeight = svgHeight / scale;
                const xMin = -visibleWidth / 2;
                const xMax = visibleWidth / 2;
                const yMin = -visibleHeight / 2;
                const yMax = visibleHeight / 2;
                
                // 绘制网格线
                const gridGroup = createSVGElement('g');
                gridGroup.setAttribute('stroke', '#eee');
                gridGroup.setAttribute('stroke-width', '1');
                
                // 横向网格线
                for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y++) {
                    if (y === 0) continue; // 坐标轴单独绘制
                    const line = createSVGElement('line');
                    line.setAttribute('x1', toSvgX(xMin));
                    line.setAttribute('y1', toSvgY(y));
                    line.setAttribute('x2', toSvgX(xMax));
                    line.setAttribute('y2', toSvgY(y));
                    gridGroup.appendChild(line);
                }
                
                // 纵向网格线
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                    if (x === 0) continue; // 坐标轴单独绘制
                    const line = createSVGElement('line');
                    line.setAttribute('x1', toSvgX(x));
                    line.setAttribute('y1', toSvgY(yMin));
                    line.setAttribute('x2', toSvgX(x));
                    line.setAttribute('y2', toSvgY(yMax));
                    gridGroup.appendChild(line);
                }
                
                svg.appendChild(gridGroup);
                
                // 绘制坐标轴
                const axisGroup = createSVGElement('g');
                axisGroup.setAttribute('stroke', '#999');
                axisGroup.setAttribute('stroke-width', '1');
                
                // x轴
                const xAxis = createSVGElement('line');
                xAxis.setAttribute('x1', toSvgX(xMin));
                xAxis.setAttribute('y1', toSvgY(0));
                xAxis.setAttribute('x2', toSvgX(xMax));
                xAxis.setAttribute('y2', toSvgY(0));
                axisGroup.appendChild(xAxis);
                
                // y轴
                const yAxis = createSVGElement('line');
                yAxis.setAttribute('x1', toSvgX(0));
                yAxis.setAttribute('y1', toSvgY(yMin));
                yAxis.setAttribute('x2', toSvgX(0));
                yAxis.setAttribute('y2', toSvgY(yMax));
                axisGroup.appendChild(yAxis);
                
                svg.appendChild(axisGroup);
                
                // 绘制刻度标签
                const labelsGroup = createSVGElement('g');
                labelsGroup.setAttribute('font-size', '12');
                
                // x轴刻度标签
                for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x++) {
                    if (x === 0) continue;
                    const text = createSVGElement('text');
                    text.setAttribute('x', toSvgX(x));
                    text.setAttribute('y', toSvgY(0) + 15);
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = x;
                    labelsGroup.appendChild(text);
                }
                
                // y轴刻度标签
                for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y++) {
                    if (y === 0) continue;
                    const text = createSVGElement('text');
                    text.setAttribute('x', toSvgX(0) - 10);
                    text.setAttribute('y', toSvgY(y) + 5);
                    text.setAttribute('text-anchor', 'end');
                    text.textContent = y;
                    labelsGroup.appendChild(text);
                }
                
                svg.appendChild(labelsGroup);
                
                // 绘制三角形
                const triangleGroup = createSVGElement('g');
                triangleGroup.setAttribute('stroke', '#000');
                triangleGroup.setAttribute('stroke-width', '2');
                
                // 线段AB
                const lineAB = createSVGElement('line');
                lineAB.setAttribute('x1', toSvgX(pointA.x));
                lineAB.setAttribute('y1', toSvgY(pointA.y));
                lineAB.setAttribute('x2', toSvgX(pointB.x));
                lineAB.setAttribute('y2', toSvgY(pointB.y));
                triangleGroup.appendChild(lineAB);
                
                // 线段AC
                const lineAC = createSVGElement('line');
                lineAC.setAttribute('x1', toSvgX(pointA.x));
                lineAC.setAttribute('y1', toSvgY(pointA.y));
                lineAC.setAttribute('x2', toSvgX(pointC.x));
                lineAC.setAttribute('y2', toSvgY(pointC.y));
                triangleGroup.appendChild(lineAC);

                // 线段AD
                const lineAD = createSVGElement('line');
                lineAD.setAttribute('x1', toSvgX(pointA.x));
                lineAD.setAttribute('y1', toSvgY(pointA.y));
                lineAD.setAttribute('x2', toSvgX(pointD.x));
                lineAD.setAttribute('y2', toSvgY(pointD.y));
                lineAD.setAttribute('stroke-dasharray', '5,5'); // 添加虚线效果
                triangleGroup.appendChild(lineAD);
                
                svg.appendChild(triangleGroup);
                
                // 绘制点
                const pointsGroup = createSVGElement('g');
                
                // 点A
                const circleA = createSVGElement('circle');
                circleA.setAttribute('cx', toSvgX(pointA.x));
                circleA.setAttribute('cy', toSvgY(pointA.y));
                circleA.setAttribute('r', '5');
                circleA.setAttribute('fill', 'blue');
                pointsGroup.appendChild(circleA);
                
                // 点B
                const circleB = createSVGElement('circle');
                circleB.setAttribute('cx', toSvgX(pointB.x));
                circleB.setAttribute('cy', toSvgY(pointB.y));
                circleB.setAttribute('r', '5');
                circleB.setAttribute('fill', 'blue');
                pointsGroup.appendChild(circleB);
                
                // 点C
                const circleC = createSVGElement('circle');
                circleC.setAttribute('cx', toSvgX(pointC.x));
                circleC.setAttribute('cy', toSvgY(pointC.y));
                circleC.setAttribute('r', '5');
                circleC.setAttribute('fill', 'blue');
                pointsGroup.appendChild(circleC);


                // 点D
                const circleD = createSVGElement('circle');
                circleD.setAttribute('cx', toSvgX(pointD.x));
                circleD.setAttribute('cy', toSvgY(pointD.y));
                circleD.setAttribute('r', '5');
                circleD.setAttribute('fill', 'blue');
                pointsGroup.appendChild(circleD);
                
                svg.appendChild(pointsGroup);
                
                // 标记点
                const markersGroup = createSVGElement('g');
                
                // 标记A
                const textA = createSVGElement('text');
                textA.setAttribute('x', toSvgX(pointA.x) + 10);
                textA.setAttribute('y', toSvgY(pointA.y) - 10);
                textA.textContent = 'A(0,0)';
                markersGroup.appendChild(textA);
                
                // 标记B
                const textB = createSVGElement('text');
                textB.setAttribute('x', toSvgX(pointB.x) + 10);
                textB.setAttribute('y', toSvgY(pointB.y) - 10);
                textB.textContent = 'B(6,1)';
                markersGroup.appendChild(textB);
                
                // 标记C
                const textC = createSVGElement('text');
                textC.setAttribute('x', toSvgX(pointC.x) + 10);
                textC.setAttribute('y', toSvgY(pointC.y) - 10);
                textC.textContent = 'C(3,6)';
                markersGroup.appendChild(textC);

                // 标记D
                const textD = createSVGElement('text');
                textD.setAttribute('x', toSvgX(pointD.x) + 10);
                textD.setAttribute('y', toSvgY(pointD.y) - 10);
                textD.textContent = 'D(-1,6)';
                markersGroup.appendChild(textD);
                
                // 向量标记
                const textU = createSVGElement('text');
                textU.setAttribute('x', toSvgX((pointA.x + pointB.x) / 2 + 0.5));
                textU.setAttribute('y', toSvgY((pointA.y + pointB.y) / 2 - 0.2));
                textU.textContent = 'u';
                markersGroup.appendChild(textU);
                
                const textV = createSVGElement('text');
                textV.setAttribute('x', toSvgX((pointA.x + pointC.x) / 2 - 0.5));
                textV.setAttribute('y', toSvgY((pointA.y + pointC.y) / 2));
                textV.textContent = 'v';
                markersGroup.appendChild(textV);
                
                svg.appendChild(markersGroup);
            }
            
            // 监听缩放变化
            document.getElementById('scale').addEventListener('input', function() {
                scale = parseInt(this.value);
                document.getElementById('scaleValue').textContent = scale;
                drawCoordinateSystem();
            });
            
            // 初始化绘图
            drawCoordinateSystem();
        </script>
    </div>
</body>
</html> 