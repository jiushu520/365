<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D01直线基础阶梯训练</title>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script id="MathJax-script" async src=".\mathjax\mathjax\es5\tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --primary-active: #0056b3;
            --border-color: #ccc;
            --background-color: #f9f9f9;
            --correct-color: green;
            --incorrect-color: red;
            --font-size: 16px;
            --max-width: 1000px; /* 增大最大宽度以容纳更多按钮 */
        }

        body {
            margin: 0;  
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: var(--background-color);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* 确保子元素水平居中 */
            text-align: center;
            margin-top: 20px;
            width: 90%;
            max-width: var(--max-width);
        }

        .type-selection {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        button.submit-button,
        button.type-button {
            padding: 10px 20px;
            font-size: var(--font-size);
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            transition: background-color 0.3s;
            margin: 5px;
        }

        button.submit-button:hover,
        button.type-button:hover {
            background-color: var(--primary-hover);
        }

        /* 激活状态的按钮样式 */
        button.type-button.active {
            background-color: var(--primary-active);
        }

        input,
        #rendered-answer {
            padding: 10px;
            font-size: var(--font-size);
            width: 80%;
            max-width: 300px;
            margin: 10px 0;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            direction: ltr; /* 确保文本方向为从左到右 */
            text-align: left; /* 确保文本左对齐 */
        }

        /* 修改后的 #rendered-answer */
        #rendered-answer {
            background-color: white;
            min-height: 40px; /* 设置最小高度，避免空时高度塌陷 */
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            margin: 10px auto; /* 上下边距为10px，左右自动 */
            text-align: left;
            width: 80%; /* 确保宽度与输入框一致 */
            max-width: 300px; /* 确保最大宽度与输入框一致 */
        }

        #result,
        #score {
            margin: 10px 0;
            font-size: 18px;
        }

        /* 历史记录使用 Flexbox */
        .history-container {
            margin-top: 20px;
            width: 100%;
            max-width: var(--max-width);
            border: 1px solid var(--border-color);
            border-collapse: collapse;
            overflow-x: auto; /* 添加横向滚动 */
        }

        .history-header,
        .history-row {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .history-header {
            background-color: #f4f4f4;
            font-weight: bold;
        }

        .history-header>div,
        .history-row>div {
            flex: 1;
            padding: 8px;
            text-align: center;
            vertical-align: top;
            box-sizing: border-box;
            word-wrap: break-word; /* 防止长内容溢出 */
        }

        .history-row:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* 限制历史记录中 SVG 的大小 */
        .history-svg {
            width: 100px; /* 固定宽度 */
            height: auto;
            max-width: 100%;
            margin: 0 auto; /* 居中显示 */
        }

        .inline-svg {
            width: 100%;
            height: auto;
        }

        .correct {
            color: var(--correct-color);
        }

        .incorrect {
            color: var(--incorrect-color);
        }

        .coordinate-system {
            border: 1px solid var(--border-color);
            background-color: white;
            margin-top: 10px;
        }

        .point-label {
            font-size: 12px;
            fill: black;
        }

        .axis,
        .line,
        .point,
        .normal-vector {
            stroke-width: 2;
        }

        .axis {
            stroke: black;
        }

        .line {
            stroke: red;
        }

        .point {
            stroke: black;
            stroke-width: 1;
        }

        .normal-vector {
            stroke: purple;
            marker-end: url(#arrow);
        }

        /* 响应式设计 */
        @media (max-width: 600px) {
            input,
            #rendered-answer {
                width: 100%;
                max-width: none;
            }

            .history-svg {
                width: 80px;
                height: auto;
            }

            /* 调整滑动条样式以适应小屏幕 */
            .slider-container {
                width: 100%;
            }
        }

        /* 新增的样式 */

        .question-and-slider {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .slider-container {
            margin-top: 1px;
            width: 100%;
            max-width: 400px;
            display: flex;
            align-items: center;
        }

        .slider-container input[type="range"] {
            flex: 1;

        }

        .slider-value {
            width: 10px;
            text-align: center;
            font-size: var(--font-size);
        }
    </style>
</head>

<body>
    <div class="game-container">
        <h3>D01直线基础阶梯训练</h3>

        <!-- 题型选择按钮 -->
        <div class="type-selection">
            <button class="type-button" data-type="slope">01求斜率</button>
            <button class="type-button" data-type="y-intercept">02求 y轴截距</button>
            <button class="type-button" data-type="x-intercept">03求 x轴截距</button>
            <button class="type-button" data-type="line-equation">04求解析式</button>
            <button class="type-button" data-type="given-x-find-y">05求纵坐标</button>
            <button class="type-button" data-type="given-y-find-x">06求横坐标</button>
            <button class="type-button" data-type="normal-vector">07求法向量</button> <!-- 新增的按钮 -->
            <!-- 可以继续添加更多按钮 -->
        </div>

        <!-- 题目区域 -->
        <div id="question-section">
            <div class="question-and-slider">
                <div id="question"></div>

 <span id="slider-value" class="slider-value">1</span>

                <!-- 数字滑动条容器 -->
                <div class="slider-container" id="slider-container">
                    <input type="range" id="number-slider" min="-10" max="10" step="0.1" value="1">
           </div>
                   
                </div>
            </div>

            <input type="text" id="answer" placeholder="输入你的答案" aria-label="输入你的答案">
            <button class="submit-button">提交答案</button>


            <div id="result"></div>
            <div id="score">正确: 0 | 错误: 0</div>

            <div class="history-container">
                <div class="history-header">
                    <div>题目</div>
                    <div>你的答案</div>
                    <div>正确答案</div>
                    <div>结果</div>
                </div>
                <div class="history-body" id="history"></div>
            </div>
        </div>
    </div>

    <script>
        // 基础工具函数
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function toHalfWidth(str) {
            return str.replace(/[\uFF01-\uFF5E]/g, char =>
                String.fromCharCode(char.charCodeAt(0) - 0xFEE0)
            ).replace(/\u3000/g, ' ');
        }

        // 基类：QuestionType
        class QuestionType {
            constructor(name) {
                this.name = name;
                this.correctAnswer = [];
            }

            generateQuestion() {
                throw new Error("Method 'generateQuestion()' must be implemented.");
            }

            checkAnswer(userAnswer) {
                throw new Error("Method 'checkAnswer()' must be implemented.");
            }

            getQuestionText() {
                throw new Error("Method 'getQuestionText()' must be implemented.");
            }

            getSVG() {
                throw new Error("Method 'getSVG()' must be implemented.");
            }
        }

        // 子类：SlopeQuestion
        class SlopeQuestion extends QuestionType {
            constructor() {
                super('slope');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, offset, direction;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        break;
                    }
                }

                this.correctAnswer = [k];
                this.currentQuestion = { xa, ya, xb, yb, k };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线斜率k=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctK = parseFloat(this.correctAnswer[0]);
                const userK = parseFloat(userAnswer);
                if (!isNaN(userK) && Math.abs(correctK - userK) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb);
            }
        }

        // 子类：YInterceptQuestion
       class YInterceptQuestion extends QuestionType {
    constructor() {
        super('y-intercept');
    }

    generateQuestion() {
        let xa, ya, xb, yb, k, b, offset, direction;

        while (true) {
            xa = getRandomInt(-5, 5);
            ya = getRandomInt(-5, 5);
            direction = Math.random() < 0.5 ? -1 : 1;

            const maxOffset = direction === 1 ? 10 - xa : xa + 10;
            const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

            if (validMaxOffset < 1) continue;

            offset = getRandomInt(1, validMaxOffset);
            xb = xa + offset * direction;

            const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
            const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

            if (possibleK.length === 0) continue;

            k = possibleK[getRandomInt(0, possibleK.length - 1)];
            yb = ya + k * offset * direction;

            if (yb >= -10 && yb <= 10) {
                // 计算 y-intercept b = ya - k * xa
                b = ya - k * xa;

                // 确保 b 是整数
                if (Number.isInteger(b)) {
                    break;
                }
            }
        }

        this.correctAnswer = [b];
        this.currentQuestion = { xa, ya, xb, yb, k, b };
        return this.currentQuestion;
    }

    getQuestionText() {
        const { xa, ya, xb, yb } = this.currentQuestion;
        return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线与 y 轴的交点(0,b), b=？ \\)`;
    }

    checkAnswer(userAnswer) {
        const correctB = parseFloat(this.correctAnswer[0]);
        const userB = parseFloat(userAnswer);
        if (!isNaN(userB) && Math.abs(correctB - userB) < 1e-2) {
            return true;
        }
        return false;
    }

    getSVG() {
        const { xa, ya, xb, yb } = this.currentQuestion;
        return generateSVG(xa, ya, xb, yb);
    }
}


        // 子类：XInterceptQuestion
 class XInterceptQuestion extends QuestionType {
    constructor() {
        super('x-intercept');
    }

    generateQuestion() {
        let xa, ya, xb, yb, k, b, offset, direction, xIntercept;

        while (true) {
            xa = getRandomInt(-5, 5);
            ya = getRandomInt(-5, 5);
            direction = Math.random() < 0.5 ? -1 : 1;

            const maxOffset = direction === 1 ? 10 - xa : xa + 10;
            const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

            if (validMaxOffset < 1) continue;

            offset = getRandomInt(1, validMaxOffset);
            xb = xa + offset * direction;

            const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
            const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

            if (possibleK.length === 0) continue;

            k = possibleK[getRandomInt(0, possibleK.length - 1)];
            yb = ya + k * offset * direction;

            if (yb >= -10 && yb <= 10) {
                // 计算 y-intercept b = ya - k * xa
                b = ya - k * xa;

                // 确保 b 不是零
                if (b !== 0) {
                    // 计算 x-intercept: x = -b / k
                    xIntercept = -b / k;

                    // 确保 xIntercept 是整数
                    if (Number.isInteger(xIntercept)) {
                        this.correctAnswer = [xIntercept];
                        this.currentQuestion = { xa, ya, xb, yb, k, b, xIntercept };
                        return this.currentQuestion;
                    }
                }
            }
        }
    }

    getQuestionText() {
        const { xa, ya, xb, yb } = this.currentQuestion;
        return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线与 x 轴的交点 (t,0), t=？ \\)`;
    }

    checkAnswer(userAnswer) {
        const correctX = parseFloat(this.correctAnswer[0]);
        const userX = parseFloat(userAnswer);
        if (!isNaN(userX) && Math.abs(correctX - userX) < 1e-2) {
            return true;
        }
        return false;
    }

    getSVG() {
        const { xa, ya, xb, yb, xIntercept } = this.currentQuestion;
        return generateSVG(xa, ya, xb, yb, false, false, xIntercept, null); // 不显示交点
    }
}


        // 子类：LineEquationQuestion
        class LineEquationQuestion extends QuestionType {
            constructor() {
                super('line-equation');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        break;
                    }
                }

                // 计算直线方程 y = kx + b
                // 格式化答案
                let equation = 'y = ';
                if (k === 0) {
                    equation += `${b}`;
                } else {
                    if (k === 1) {
                        equation += `x`;
                    } else if (k === -1) {
                        equation += `-x`;
                    } else {
                        equation += `${k}x`;
                    }

                    if (b > 0) {
                        equation += ` + ${b}`;
                    } else if (b < 0) {
                        equation += ` - ${Math.abs(b)}`;
                    }
                    // 如果 b == 0, omit
                }

                this.correctAnswer = [equation];
                this.currentQuestion = { xa, ya, xb, yb, k, b };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线解析式为 y = ? \\)`;
            }

            checkAnswer(userAnswer) {
                // 解析用户输入的方程
                // 期望格式：y = kx + b 或 y=kx+b（不区分空格）
                const regex = /^y\s*=\s*([+-]?(\d+(\.\d+)?)?)x\s*([+-]\s*\d+(\.\d+)?)?$/;
                const match = userAnswer.replace(/\s+/g, '').match(regex);
                if (!match) return false;

                let userK = match[1];
                let userB = match[4];

                // 处理特殊情况
                if (userK === '' || userK === '+') {
                    userK = '1';
                } else if (userK === '-') {
                    userK = '-1';
                }

                userK = parseFloat(userK);
                userB = userB ? parseFloat(userB.replace(/\s+/g, '')) : 0;

                const correctK = this.currentQuestion.k;
                const correctB = this.currentQuestion.b;

                if (isNaN(userK) || isNaN(userB)) return false;

                if (Math.abs(correctK - userK) < 1e-2 && Math.abs(correctB - userB) < 1e-2) {
                    return true;
                }

                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb, false, true); // 传入参数指示需突出显示直线方程
            }
        }

        // 子类：GivenXFindYQuestion
      class GivenXFindYQuestion extends QuestionType {
    constructor() {
        super('given-x-find-y');
    }

    generateQuestion() {
        let xa, ya, xb, yb, k, b, offset, direction, givenX;

        while (true) {
            xa = getRandomInt(-5, 5);
            ya = getRandomInt(-5, 5);
            direction = Math.random() < 0.5 ? -1 : 1;

            const maxOffset = direction === 1 ? 10 - xa : xa + 10;
            const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

            if (validMaxOffset < 1) continue;

            offset = getRandomInt(1, validMaxOffset);
            xb = xa + offset * direction;

            const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
            const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

            if (possibleK.length === 0) continue;

            k = possibleK[getRandomInt(0, possibleK.length - 1)];
            yb = ya + k * offset * direction;

            if (yb >= -10 && yb <= 10) {
                // 计算 y-intercept b = ya - k * xa
                b = ya - k * xa;
                break;
            }
        }

        // 随机选择一个 x 值在直线上，计算对应的 y 值，确保结果是整数
        givenX = getRandomInt(-10, 10);

        const givenY = k * givenX + b;

        if (Number.isInteger(givenY)) {
            this.correctAnswer = [givenY];
            this.currentQuestion = { xa, ya, xb, yb, k, b, givenX, givenY };
            return this.currentQuestion;
        } else {
            // 如果 y 不是整数，重新生成题目
            return this.generateQuestion();
        }
    }

    getQuestionText() {
        const { givenX, xa, ya, xb, yb } = this.currentQuestion;
        return `\\( 在过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线上，x=${givenX} 时，y=？ \\)`;
    }

    checkAnswer(userAnswer) {
        const correctY = parseFloat(this.correctAnswer[0]);
        const userY = parseFloat(userAnswer);
        if (!isNaN(userY) && Math.abs(correctY - userY) < 1e-2) {
            return true;
        }
        return false;
    }

    getSVG() {
        const { xa, ya, xb, yb, givenX, givenY } = this.currentQuestion;
        // 在给定的 x 值处显示一条垂直线 x=givenX
        return generateSVG(xa, ya, xb, yb, false, false, givenX, '?');
    }
}


        // 子类：GivenYFindXQuestion
        class GivenYFindXQuestion extends QuestionType {
            constructor() {
                super('given-y-find-x');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction, givenY;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        break;
                    }
                }

                // 随机选择一个 y 值在直线上
                givenY = getRandomInt(-10, 10);

                // 计算对应的 x 值，如果 k != 0
                let givenX;
                if (k !== 0) {
                    givenX = (givenY - b) / k;
                    // 确保 x 在合理范围内
                    if (givenX < -10 || givenX > 10) {
                        return this.generateQuestion();
                    }
                    // 保留两位小数
                    givenX = parseFloat(givenX.toFixed(2));
                } else {
                    // 如果 k = 0，直线平行于 x 轴，没有 x 对应
                    return this.generateQuestion();
                }

                this.correctAnswer = [givenX];
                this.currentQuestion = { xa, ya, xb, yb, k, b, givenX, givenY };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { givenY, xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 在过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线上，y=${givenY} 时，x=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctX = parseFloat(this.correctAnswer[0]);
                const userX = parseFloat(userAnswer);
                if (!isNaN(userX) && Math.abs(correctX - userX) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb, givenX, givenY } = this.currentQuestion;
                // 在给定的 y 值处显示一条水平线 y=givenY
                return generateSVG(xa, ya, xb, yb, false, false, null, givenY);
            }
        }

        // 子类：NormalVectorQuestion (新增题型：求法向量)
        class NormalVectorQuestion extends QuestionType {
            constructor() {
                super('normal-vector');
            }

            generateQuestion() {
                let xa, ya, xb, yb, normalX, normalY;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    xb = getRandomInt(-5, 5);
                    yb = getRandomInt(-5, 5);

                    // 确保AB不是重合
                    if (xa === xb && ya === yb) continue;

                    // 计算法向量
                    normalX = ya - yb;
                    normalY = xb - xa;

                    // 规范化为互质整数
                    const gcd = this.getGCD(Math.abs(normalX), Math.abs(normalY));
                    if (gcd === 0) continue; // 避免(0,0)

                    normalX /= gcd;
                    normalY /= gcd;

                    // 确保法向量的起点为原点，终点为 (normalX, normalY)
                    // 可以选择 (normalX, normalY) 或 (-normalX, -normalY)
                    this.correctAnswer = [`(${normalX}, ${normalY})`, `(${-normalX}, ${-normalY})`];
                    this.currentQuestion = { xa, ya, xb, yb, normalX, normalY };
                    break;
                }

                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 求过A(${xa},${ya}),B(${xb},${yb})直线AB的法向量。\\textup{答案格式(a,b)，a,b互质。} \\)`;
            }

            checkAnswer(userAnswer) {
                // 去除空格和括号
                const cleaned = userAnswer.replace(/\s+/g, '').replace(/[()]/g, '');
                const parts = cleaned.split(',');
                if (parts.length !== 2) return false;

                let userX = parseInt(parts[0], 10);
                let userY = parseInt(parts[1], 10);

                if (isNaN(userX) || isNaN(userY)) return false;

                // 检查是否与正确答案之一匹配
                const answer1 = this.correctAnswer[0].replace(/[()]/g, '').split(',').map(Number);
                const answer2 = this.correctAnswer[1].replace(/[()]/g, '').split(',').map(Number);

                return (userX === answer1[0] && userY === answer1[1]) ||
                    (userX === answer2[0] && userY === answer2[1]);
            }

            getSVG() {
                const { xa, ya, xb, yb, normalX, normalY } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb, false, false, null, null, normalX, normalY);
            }

            // 辅助函数：计算最大公约数
            getGCD(a, b) {
                if (b === 0) return a;
                return this.getGCD(b, a % b);
            }
        }

        // 工厂模式：根据题型名称创建对应的题型对象
        function createQuestionType(type) {
            switch (type) {
                case 'slope':
                    return new SlopeQuestion();
                case 'y-intercept':
                    return new YInterceptQuestion();
                case 'x-intercept':
                    return new XInterceptQuestion();
                case 'line-equation':
                    return new LineEquationQuestion();
                case 'given-x-find-y':
                    return new GivenXFindYQuestion();
                case 'given-y-find-x':
                    return new GivenYFindXQuestion();
                case 'normal-vector':
                    return new NormalVectorQuestion(); // 支持新题型
                default:
                    throw new Error(`未知的题型: ${type}`);
            }
        }

        // SVG 生成函数（增强以支持不同的突出显示）
        function generateSVG(xa, ya, xb, yb, highlightXIntercept = false, highlightLineEquation = false, givenX = null, givenY = null, normalX = null, normalY = null) {
            const size = 400;
            const unit = 20;
            const center = size / 2;

            const coordToSvg = (x, y) => ({
                x: center + x * unit,
                y: center - y * unit
            });

            const pointA = coordToSvg(xa, ya);
            const pointB = coordToSvg(xb, yb);

            let lineStart, lineEnd;

            if (xb !== xa) {
                const slope = (yb - ya) / (xb - xa);
                const intercept = ya - slope * xa;

                const intersections = findLineIntersections(slope, intercept);

                if (intersections.length >= 2) {
                    const svgStart = coordToSvg(intersections[0].x, intersections[0].y);
                    const svgEnd = coordToSvg(intersections[1].x, intersections[1].y);
                    lineStart = svgStart;
                    lineEnd = svgEnd;
                } else {
                    // 如果交点不足两个，退回仅绘制两点之间的线
                    lineStart = pointA;
                    lineEnd = pointB;
                }
            } else {
                // 垂直线
                const x = center + xa * unit;
                lineStart = { x: x, y: 0 };
                lineEnd = { x: x, y: size };
            }

            // 计算是否需要突出显示 x-intercept
            let xInterceptPoint = null;
            if (highlightXIntercept && givenX !== '?') {
                // 在 LineEquationQuestion 和 XInterceptQuestion 中传入 xIntercept
                xInterceptPoint = coordToSvg(givenX, 0);
            }

            // 计算是否需要突出显示给定的 x 或 y
            let givenLine = '';
            if (givenX !== null && givenY !== null) {
                if (givenX !== '?') {
                    // 绘制垂直线 x=givenX
                    const x = coordToSvg(givenX, 0).x;
                    givenLine = `<line x1="${x}" y1="0" x2="${x}" y2="${size}" stroke="blue" stroke-dasharray="5,5" />`;
                } else if (givenY !== '?') {
                    // 绘制水平线 y=givenY
                    const y = coordToSvg(0, givenY).y;
                    givenLine = `<line x1="0" y1="${y}" x2="${size}" y2="${y}" stroke="blue" stroke-dasharray="5,5" />`;
                }
            }

            // 处理法向量
            let normalVectorSVG = '';
            if (normalX !== null && normalY !== null) {
                const origin = coordToSvg(0, 0);
                const normalEnd = coordToSvg(normalX, normalY);
                normalVectorSVG = `
                    <defs>
                        <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
                            <path d="M0,0 L10,3 L0,6" fill="purple" />
                        </marker>
                    </defs>
                    <line x1="${origin.x}" y1="${origin.y}" x2="${normalEnd.x}" y2="${normalEnd.y}" class="normal-vector" stroke="purple" marker-end="url(#arrow)" />
                    <text x="${normalEnd.x + 5}" y="${normalEnd.y - 5}" class="point-label">法向量</text>
                `;
            }

            // 处理给定值为 '?' 的情况
            let givenPointLabel = '';
            if (givenX !== '?' && givenY !== '?') {
                // 无需显示，因为已绘制线条
                givenPointLabel = '';
            }

            return `
                <svg viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" class="inline-svg">
                    <!-- 坐标轴 -->
                    <line x1="0" y1="${center}" x2="${size}" y2="${center}" class="axis" />
                    <line x1="${center}" y1="0" x2="${center}" y2="${size}" class="axis" />

                    <!-- 给定的垂直或水平线 -->
                    ${givenLine}

                    <!-- 法向量 -->
                    ${normalVectorSVG}

                    <!-- 斜率直线 -->
                    <line x1="${lineStart.x}" y1="${lineStart.y}" x2="${lineEnd.x}" y2="${lineEnd.y}" class="line" />

                    <!-- 点 A -->
                    <circle cx="${pointA.x}" cy="${pointA.y}" r="5" fill="blue" class="point" />
                    <text x="${pointA.x + 5}" y="${pointA.y - 5}" class="point-label">A(${xa},${ya})</text>

                    <!-- 点 B -->
                    <circle cx="${pointB.x}" cy="${pointB.y}" r="5" fill="red" class="point" />
                    <text x="${pointB.x + 5}" y="${pointB.y - 5}" class="point-label">B(${xb},${yb})</text>

                    ${xInterceptPoint ?
                        `<!-- x-intercept 点 -->
                        <circle cx="${xInterceptPoint.x}" cy="${xInterceptPoint.y}" r="5" fill="green" class="point" />
                        <text x="${xInterceptPoint.x + 5}" y="${xInterceptPoint.y - 5}" class="point-label">X₀(${givenX.toFixed(2)},0)</text>`
                        : ''}
                </svg>
            `;
        }

        function findLineIntersections(k, b) {
            const intersections = [];

            // 直线与 x = -10 的交点
            let y = k * (-10) + b;
            if (y >= -10 && y <= 10) {
                intersections.push({ x: -10, y: y });
            }

            // 直线与 x = 10 的交点
            y = k * 10 + b;
            if (y >= -10 && y <= 10) {
                intersections.push({ x: 10, y: y });
            }

            // 直线与 y = 10 的交点
            if (k !== 0) { // 避免除以零
                let x = (10 - b) / k;
                if (x >= -10 && x <= 10) {
                    intersections.push({ x: x, y: 10 });
                }

                // 直线与 y = -10 的交点
                x = (-10 - b) / k;
                if (x >= -10 && x <= 10) {
                    intersections.push({ x: x, y: -10 });
                }
            }

            // 移除重复交点
            const unique = [];
            const map = new Map();
            intersections.forEach(pt => {
                const key = `${pt.x.toFixed(5)},${pt.y.toFixed(5)}`; // 使用固定小数位防止浮点数问题
                if (!map.has(key)) {
                    map.set(key, true);
                    unique.push(pt);
                }
            });

            return unique.slice(0, 2); // 返回前两个唯一交点
        }

        // 主应用逻辑
        class App {
            constructor() {
                this.state = {
                    currentQuestionType: null,
                    questionInstance: null,
                    correctCount: 0,
                    incorrectCount: 0
                };

                // 绑定DOM元素
                this.questionElement = document.getElementById('question');
                this.renderedAnswerElement = document.getElementById('rendered-answer');
                this.answerInput = document.getElementById('answer');
                this.submitButton = document.querySelector('.submit-button');
                this.resultElement = document.getElementById('result');
                this.scoreElement = document.getElementById('score');
                this.historyElement = document.getElementById('history');
                this.typeButtons = document.querySelectorAll('.type-button');
                this.sliderContainer = document.getElementById('slider-container');
                this.slider = document.getElementById('number-slider');
                this.sliderValueDisplay = document.getElementById('slider-value');

                // 绑定事件
                this.bindEvents();

                // 自动选择并生成第一类题型
                this.initializeDefaultQuestionType();
            }

            bindEvents() {
                // 题型选择按钮
                this.typeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const type = button.getAttribute('data-type');
                        this.selectQuestionType(type);
                    });
                });

                // 提交按钮
                this.submitButton.addEventListener('click', () => this.checkAnswer());

                // 回车键提交
                this.answerInput.addEventListener('keyup', event => {
                    if (event.key === 'Enter') this.checkAnswer();
                });

                // 实时预览
                this.answerInput.addEventListener('input', () => this.updatePreview());

                // 数字滑动条变化事件
                this.slider.addEventListener('input', () => {
                    const value = parseFloat(this.slider.value).toFixed(0);
                    this.sliderValueDisplay.textContent = value;
                    this.answerInput.value = value;
                    this.updatePreview();
                });
            }

            initializeDefaultQuestionType() {
                if (this.typeButtons.length > 0) {
                    const firstButton = this.typeButtons[0];
                    const type = firstButton.getAttribute('data-type');
                    this.selectQuestionType(type);

                    // 添加激活状态的样式
                    this.typeButtons.forEach(btn => btn.classList.remove('active'));
                    firstButton.classList.add('active');
                }
            }

            selectQuestionType(type) {
                if (this.state.currentQuestionType !== type) {
                    this.state.currentQuestionType = type;
                    this.state.questionInstance = createQuestionType(type);
                    this.newQuestion();

                    // 更新按钮的激活状态
                    this.typeButtons.forEach(btn => {
                        if (btn.getAttribute('data-type') === type) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });

                    // 根据题型决定是否显示滑动条
                    const typesWithSlider = ['slope', 'y-intercept', 'x-intercept', 'given-x-find-y', 'given-y-find-x'];
                    if (typesWithSlider.includes(type)) {
                        this.sliderContainer.style.display = 'flex';
                    } else {
                        this.sliderContainer.style.display = 'none';
                        this.answerInput.value = '';
                        this.updatePreview();
                    }
                }
            }

            newQuestion() {
                const questionData = this.state.questionInstance.generateQuestion();
                this.renderQuestion();
                this.clearInput();
            }

            renderQuestion() {
                const questionText = this.state.questionInstance.getQuestionText();
                const svg = this.state.questionInstance.getSVG();
                this.questionElement.innerHTML = `${questionText}<div class="coordinate-system">${svg}</div>`;
                MathJax.typesetPromise([this.questionElement]).catch(console.error);
            }

            clearInput() {
                this.answerInput.value = '';
                this.resultElement.textContent = '';
                this.resultElement.className = '';
                this.updateRenderedAnswer('');
                if (this.sliderContainer.style.display === 'flex') {
                    this.slider.value = 0;
                    this.sliderValueDisplay.textContent = '0';
                }
            }

            updateRenderedAnswer(content) {
                if (content) {
                    this.renderedAnswerElement.innerHTML = `\\(${content}\\)`;
                } else {
                    this.renderedAnswerElement.innerHTML = '\\(\\text{您的答案将实时渲染在此处}\\)';
                }
                MathJax.typesetPromise([this.renderedAnswerElement]).catch(console.error);
            }

            updatePreview() {
                const input = this.answerInput.value;
                this.updateRenderedAnswer(input);
            }

            checkAnswer() {
                const userAnswer = toHalfWidth(this.answerInput.value.trim());
                if (!userAnswer) {
                    this.showResult('请输入答案！', false);
                    return;
                }

                const isCorrect = this.state.questionInstance.checkAnswer(userAnswer);

                if (isCorrect) {
                    this.showResult('正确!', true);
                    this.state.correctCount++;
                } else {
                    let correctAnswers;
                    if (this.state.currentQuestionType === 'line-equation') {
                        correctAnswers = this.state.questionInstance.correctAnswer.join(' 或 ');
                    } else if (this.state.currentQuestionType === 'normal-vector') {
                        correctAnswers = this.state.questionInstance.correctAnswer.join(' 或 ');
                    } else {
                        correctAnswers = this.state.questionInstance.correctAnswer.join(' 或 ');
                    }
                    this.showResult(`错误。正确答案是: ${correctAnswers}`, false);
                    this.state.incorrectCount++;
                }

                this.updateScore();
                this.updateHistory(isCorrect);
                this.newQuestion();
            }

            showResult(message, isCorrect) {
                this.resultElement.textContent = message;
                this.resultElement.className = isCorrect ? 'correct' : 'incorrect';
            }

            updateScore() {
                this.scoreElement.textContent = `正确: ${this.state.correctCount} | 错误: ${this.state.incorrectCount}`;
            }

            updateHistory(isCorrect) {
                const row = document.createElement('div');
                row.classList.add('history-row', isCorrect ? 'correct' : 'incorrect');

                const questionClone = this.questionElement.cloneNode(true);

                // 给 SVG 添加类以便在历史记录中缩小
                const svg = questionClone.querySelector('svg');
                if (svg) {
                    svg.classList.add('history-svg');
                    svg.removeAttribute('width');
                    svg.removeAttribute('height');
                }

                let userAnswerFormatted;
                if (this.state.currentQuestionType === 'normal-vector') {
                    userAnswerFormatted = `\\(${this.answerInput.value.trim()}\\)`;
                } else {
                    userAnswerFormatted = `\\(${this.answerInput.value}\\)`;
                }

                let correctAnswerFormatted;
                if (this.state.currentQuestionType === 'line-equation') {
                    correctAnswerFormatted = `\\(${this.state.questionInstance.correctAnswer.join('\\) 或 \\(')}\\)`;
                } else if (this.state.currentQuestionType === 'normal-vector') {
                    correctAnswerFormatted = this.state.questionInstance.correctAnswer.map(ans => `\\(${ans}\\)`).join(' 或 ');
                } else {
                    correctAnswerFormatted = `\\(${this.state.questionInstance.correctAnswer.join(' 或 ')}\\)`;
                }

                const resultText = isCorrect ? '正确' : '错误';

                row.innerHTML = `
                    <div>${questionClone.innerHTML}</div>
                    <div>${userAnswerFormatted}</div>
                    <div>${correctAnswerFormatted}</div>
                    <div>${resultText}</div>
                `;
                this.historyElement.prepend(row);

                MathJax.typesetPromise([row]).catch(console.error);
            }
        }

        // 初始化应用
        document.addEventListener("DOMContentLoaded", () => {
            const app = new App();
        });
    </script>
</body>

</html>
