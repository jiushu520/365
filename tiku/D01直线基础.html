<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D01直线基础阶梯训练</title>

    <!-- 引入 MathJax 用于渲染 LaTeX 数学公式 -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --primary-active: #0056b3;
            --border-color: #ccc;
            --background-color: #f9f9f9;
            --correct-color: green;
            --incorrect-color: red;
            --font-size: 16px;
            --max-width: 1000px; /* 增大最大宽度以容纳更多按钮 */
        }

        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: var(--background-color);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* 确保子元素水平居中 */
            text-align: center;
            margin-top: 20px;
            width: 90%;
            max-width: var(--max-width);
        }

        .type-selection {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        button.submit-button,
        button.type-button {
            padding: 10px 20px;
            font-size: var(--font-size);
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            transition: background-color 0.3s;
            margin: 5px;
        }

        button.submit-button:hover,
        button.type-button:hover {
            background-color: var(--primary-hover);
        }

        /* 激活状态的按钮样式 */
        button.type-button.active {
            background-color: var(--primary-active);
        }

        input,
        #rendered-answer {
            padding: 10px;
            font-size: var(--font-size);
            width: 80%;
            max-width: 300px;
            margin: 10px 0;
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        /* 修改后的 #rendered-answer */
        #rendered-answer {
            background-color: white;
            min-height: 40px; /* 设置最小高度，避免空时高度塌陷 */
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            margin: 10px auto; /* 上下边距为10px，左右自动 */
            text-align: left;
            width: 80%; /* 确保宽度与输入框一致 */
            max-width: 300px; /* 确保最大宽度与输入框一致 */
        }

        #result,
        #score {
            margin: 10px 0;
            font-size: 18px;
        }

        /* 历史记录使用 Flexbox */
        .history-container {
            margin-top: 20px;
            width: 100%;
            max-width: var(--max-width);
            border: 1px solid var(--border-color);
            border-collapse: collapse;
            overflow-x: auto; /* 添加横向滚动 */
        }

        .history-header,
        .history-row {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .history-header {
            background-color: #f4f4f4;
            font-weight: bold;
        }

        .history-header>div,
        .history-row>div {
            flex: 1;
            padding: 8px;
            text-align: center;
            vertical-align: top;
            box-sizing: border-box;
            word-wrap: break-word; /* 防止长内容溢出 */
        }

        .history-row:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* 限制历史记录中 SVG 的大小 */
        .history-svg {
            width: 100px; /* 固定宽度 */
            height: auto;
            max-width: 100%;
            margin: 0 auto; /* 居中显示 */
        }

        .inline-svg {
            width: 100%;
            height: auto;
        }

        .correct {
            color: var(--correct-color);
        }

        .incorrect {
            color: var(--incorrect-color);
        }

        .coordinate-system {
            border: 1px solid var(--border-color);
            background-color: white;
            margin-top: 10px;
        }

        .point-label {
            font-size: 12px;
            fill: black;
        }

        .axis,
        .line,
        .point {
            stroke-width: 2;
        }

        .axis {
            stroke: black;
        }

        .line {
            stroke: red;
        }

        .point {
            stroke: black;
            stroke-width: 1;
        }

        /* 响应式设计 */
        @media (max-width: 600px) {
            input,
            #rendered-answer {
                width: 100%;
                max-width: none;
            }

            .history-svg {
                width: 80px;
                height: auto;
            }
        }
    </style>
</head>

<body>
    <div class="game-container">
        <h3>D01直线基础阶梯训练</h3>

        <!-- 题型选择按钮 -->
        <div class="type-selection">
            <button class="type-button" data-type="slope">01求斜率</button>
            <button class="type-button" data-type="y-intercept">02求 y截距</button>
            <button class="type-button" data-type="x-intercept">03求 x截距</button>
            <button class="type-button" data-type="line-equation">04求解析式</button>
            <button class="type-button" data-type="given-x-find-y">05求纵坐标</button>
            <button class="type-button" data-type="given-y-find-x">06求横坐标</button>
            <!-- 可以继续添加更多按钮 -->
        </div>

        <!-- 题目区域 -->
        <div id="question-section">
            <div id="question"></div>
            
            <input type="text" id="answer" placeholder="输入你的答案" aria-label="输入你的答案">
            <button class="submit-button">提交答案</button>
            <!-- rendered-answer 始终显示，并添加默认提示 -->

            <div id="result"></div>
            <div id="score">正确: 0 | 错误: 0</div>

            <div class="history-container">
                <div class="history-header">
                    <div>题目</div>
                    <div>你的答案</div>
                    <div>正确答案</div>
                    <div>结果</div>
                </div>
                <div class="history-body" id="history"></div>
            </div>
        </div>
    </div>

    <script>
        // 基础工具函数
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function toHalfWidth(str) {
            return str.replace(/[\uFF01-\uFF5E]/g, char =>
                String.fromCharCode(char.charCodeAt(0) - 0xFEE0)
            ).replace(/\u3000/g, ' ');
        }

        // 基类：QuestionType
        class QuestionType {
            constructor(name) {
                this.name = name;
                this.correctAnswer = [];
            }

            generateQuestion() {
                throw new Error("Method 'generateQuestion()' must be implemented.");
            }

            checkAnswer(userAnswer) {
                throw new Error("Method 'checkAnswer()' must be implemented.");
            }

            getQuestionText() {
                throw new Error("Method 'getQuestionText()' must be implemented.");
            }

            getSVG() {
                throw new Error("Method 'getSVG()' must be implemented.");
            }
        }

        // 子类：SlopeQuestion
        class SlopeQuestion extends QuestionType {
            constructor() {
                super('slope');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, offset, direction;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        break;
                    }
                }

                this.correctAnswer = [`${k}`];
                this.currentQuestion = { xa, ya, xb, yb, k };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线斜率k=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctK = parseFloat(this.correctAnswer[0]);
                const userK = parseFloat(userAnswer);
                if (!isNaN(userK) && Math.abs(correctK - userK) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb);
            }
        }

        // 子类：YInterceptQuestion
        class YInterceptQuestion extends QuestionType {
            constructor() {
                super('y-intercept');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        if (b >= -10 && b <= 10) {
                            break;
                        }
                    }
                }

                this.correctAnswer = [`${b}`];
                this.currentQuestion = { xa, ya, xb, yb, b };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线与 y 轴的交点 b=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctB = parseFloat(this.correctAnswer[0]);
                const userB = parseFloat(userAnswer);
                if (!isNaN(userB) && Math.abs(correctB - userB) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb);
            }
        }

        // 子类：XInterceptQuestion
        class XInterceptQuestion extends QuestionType {
            constructor() {
                super('x-intercept');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction, xIntercept;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        if (b !== 0) { // 确保直线与 x 轴有交点
                            break;
                        }
                    }
                }

                // 计算 x-intercept: x = -b / k
                xIntercept = (-b) / k;
                if (xIntercept < -10 || xIntercept > 10) {
                    // 如果 x-intercept 不在坐标系范围内，重新生成
                    return this.generateQuestion();
                }

                this.correctAnswer = [`${xIntercept}`];
                this.currentQuestion = { xa, ya, xb, yb, k, b, xIntercept };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线与 x 轴的交点 x=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctX = parseFloat(this.correctAnswer[0]);
                const userX = parseFloat(userAnswer);
                if (!isNaN(userX) && Math.abs(correctX - userX) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb, xIntercept } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb, true); // 传入参数指示需突出显示 x-intercept
            }
        }

        // 子类：LineEquationQuestion
        class LineEquationQuestion extends QuestionType {
            constructor() {
                super('line-equation');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        break;
                    }
                }

                // 计算直线方程 y = kx + b
                // 格式化答案
                let equation = 'y = ';
                if (k === 0) {
                    equation += `${b}`;
                } else {
                    if (k === 1) {
                        equation += `x`;
                    } else if (k === -1) {
                        equation += `-x`;
                    } else {
                        equation += `${k}x`;
                    }

                    if (b > 0) {
                        equation += ` + ${b}`;
                    } else if (b < 0) {
                        equation += ` - ${Math.abs(b)}`;
                    }
                    // 如果 b == 0, omit
                }

                this.correctAnswer = [`${equation}`];
                this.currentQuestion = { xa, ya, xb, yb, k, b };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线解析式为 y = ? \\)`;
            }

            checkAnswer(userAnswer) {
                // 解析用户输入的方程
                // 期望格式：y = kx + b 或 y=kx+b（不区分空格）
                const regex = /^y\s*=\s*([+-]?(\d+(\.\d+)?)?)x\s*([+-]\s*\d+(\.\d+)?)?$/
                const match = userAnswer.replace(/\s+/g, '').match(regex);
                if (!match) return false;

                let userK = match[1];
                let userB = match[4];

                // 处理特殊情况
                if (userK === '' || userK === '+') {
                    userK = '1';
                } else if (userK === '-') {
                    userK = '-1';
                }

                userK = parseFloat(userK);
                userB = userB ? parseFloat(userB.replace(/\s+/g, '')) : 0;

                const correctK = this.currentQuestion.k;
                const correctB = this.currentQuestion.b;

                if (isNaN(userK) || isNaN(userB)) return false;

                if (Math.abs(correctK - userK) < 1e-2 && Math.abs(correctB - userB) < 1e-2) {
                    return true;
                }

                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb } = this.currentQuestion;
                return generateSVG(xa, ya, xb, yb, false, true); // 传入参数指示需突出显示直线方程
            }
        }

        // 子类：GivenXFindYQuestion
        class GivenXFindYQuestion extends QuestionType {
            constructor() {
                super('given-x-find-y');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction, givenX;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        break;
                    }
                }

                // 随机选择一个 x 值在直线上
                givenX = getRandomInt(-10, 10);

                // 计算对应的 y 值
                const givenY = k * givenX + b;

                this.correctAnswer = [`${givenY}`];
                this.currentQuestion = { xa, ya, xb, yb, k, b, givenX, givenY };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { givenX, xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 在过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线上，x=${givenX} 时，y=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctY = parseFloat(this.correctAnswer[0]);
                const userY = parseFloat(userAnswer);
                if (!isNaN(userY) && Math.abs(correctY - userY) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb, givenX, givenY } = this.currentQuestion;
                // 在给定的 x 值处显示一条垂直线 x=givenX
                return generateSVG(xa, ya, xb, yb, false, false, givenX, '?');
            }
        }

        // 子类：GivenYFindXQuestion
        class GivenYFindXQuestion extends QuestionType {
            constructor() {
                super('given-y-find-x');
            }

            generateQuestion() {
                let xa, ya, xb, yb, k, b, offset, direction, givenY;

                while (true) {
                    xa = getRandomInt(-5, 5);
                    ya = getRandomInt(-5, 5);
                    direction = Math.random() < 0.5 ? -1 : 1;

                    const maxOffset = direction === 1 ? 10 - xa : xa + 10;
                    const validMaxOffset = Math.max(1, Math.floor(Math.min(maxOffset, 10)));

                    if (validMaxOffset < 1) continue;

                    offset = getRandomInt(1, validMaxOffset);
                    xb = xa + offset * direction;

                    const maxK = Math.max(1, Math.floor((10 - Math.abs(ya)) / offset));
                    const possibleK = [...Array(maxK).keys()].slice(1).flatMap(i => [i, -i]);

                    if (possibleK.length === 0) continue;

                    k = possibleK[getRandomInt(0, possibleK.length - 1)];
                    yb = ya + k * offset * direction;

                    if (yb >= -10 && yb <= 10) {
                        // 计算 y-intercept b = ya - k * xa
                        b = ya - k * xa;
                        break;
                    }
                }

                // 随机选择一个 y 值在直线上
                givenY = getRandomInt(-10, 10);

                // 计算对应的 x 值，如果 k != 0
                let givenX;
                if (k !== 0) {
                    givenX = (givenY - b) / k;
                    // 确保 x 在合理范围内
                    if (givenX < -10 || givenX > 10) {
                        return this.generateQuestion();
                    }
                    // 保留两位小数
                    givenX = parseFloat(givenX.toFixed(2));
                } else {
                    // 如果 k = 0，直线平行于 x 轴，没有 x 对应
                    return this.generateQuestion();
                }

                this.correctAnswer = [`${givenX}`];
                this.currentQuestion = { xa, ya, xb, yb, k, b, givenX, givenY };
                return this.currentQuestion;
            }

            getQuestionText() {
                const { givenY, xa, ya, xb, yb } = this.currentQuestion;
                return `\\( 在过点A(${xa}, ${ya}), B(${xb}, ${yb})的直线上，y=${givenY} 时，x=？ \\)`;
            }

            checkAnswer(userAnswer) {
                const correctX = parseFloat(this.correctAnswer[0]);
                const userX = parseFloat(userAnswer);
                if (!isNaN(userX) && Math.abs(correctX - userX) < 1e-2) {
                    return true;
                }
                return false;
            }

            getSVG() {
                const { xa, ya, xb, yb, givenX, givenY } = this.currentQuestion;
                // 在给定的 y 值处显示一条水平线 y=givenY
                return generateSVG(xa, ya, xb, yb, false, false, '?', givenY);
            }
        }

        // 工厂模式：根据题型名称创建对应的题型对象
        function createQuestionType(type) {
            switch (type) {
                case 'slope':
                    return new SlopeQuestion();
                case 'y-intercept':
                    return new YInterceptQuestion();
                case 'x-intercept':
                    return new XInterceptQuestion();
                case 'line-equation':
                    return new LineEquationQuestion();
                case 'given-x-find-y':
                    return new GivenXFindYQuestion();
                case 'given-y-find-x':
                    return new GivenYFindXQuestion();
                default:
                    throw new Error(`未知的题型: ${type}`);
            }
        }

        // SVG 生成函数（增强以支持不同的突出显示）
        function generateSVG(xa, ya, xb, yb, highlightXIntercept = false, highlightLineEquation = false, givenX = null, givenY = null) {
            const size = 400;
            const unit = 20;
            const center = size / 2;

            const coordToSvg = (x, y) => ({
                x: center + x * unit,
                y: center - y * unit
            });

            const pointA = coordToSvg(xa, ya);
            const pointB = coordToSvg(xb, yb);

            let lineStart, lineEnd;

            if (xb !== xa) {
                const slope = (yb - ya) / (xb - xa);
                const intercept = ya - slope * xa;

                const intersections = findLineIntersections(slope, intercept);

                if (intersections.length >= 2) {
                    const svgStart = coordToSvg(intersections[0].x, intersections[0].y);
                    const svgEnd = coordToSvg(intersections[1].x, intersections[1].y);
                    lineStart = svgStart;
                    lineEnd = svgEnd;
                } else {
                    // 如果交点不足两个，退回仅绘制两点之间的线
                    lineStart = pointA;
                    lineEnd = pointB;
                }
            } else {
                // 垂直线
                const x = center + xa * unit;
                lineStart = { x: x, y: 0 };
                lineEnd = { x: x, y: size };
            }

            // 计算是否需要突出显示 x-intercept
            let xInterceptPoint = null;
            if (highlightXIntercept && givenX !== '?') {
                // 在 `LineEquationQuestion` 和 `XInterceptQuestion` 中传入 `xIntercept`
                if (typeof this !== 'undefined' && this.xIntercept !== undefined) {
                    xInterceptPoint = coordToSvg(this.xIntercept, 0);
                }
            }

            // 计算是否需要突出显示给定的 x 或 y
            let givenLine = '';
            if (givenX !== null && givenY !== null) {
                if (givenX !== '?') {
                    // 绘制垂直线 x=givenX
                    const x = coordToSvg(givenX, 0).x;
                    givenLine = `<line x1="${x}" y1="0" x2="${x}" y2="${size}" stroke="blue" stroke-dasharray="5,5" />`;
                } else if (givenY !== '?') {
                    // 绘制水平线 y=givenY
                    const y = coordToSvg(0, givenY).y;
                    givenLine = `<line x1="0" y1="${y}" x2="${size}" y2="${y}" stroke="blue" stroke-dasharray="5,5" />`;
                }
            }

            // 处理给定值为 '?' 的情况
            let givenPointLabel = '';
            if (givenX !== '?' && givenY !== '?') {
                // 无需显示，因为已绘制线条
                givenPointLabel = '';
            }

            return `
                <svg viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" class="inline-svg">
                    <!-- 坐标轴 -->
                    <line x1="0" y1="${center}" x2="${size}" y2="${center}" class="axis" />
                    <line x1="${center}" y1="0" x2="${center}" y2="${size}" class="axis" />

                    <!-- 给定的垂直或水平线 -->
                    ${givenLine}

                    <!-- 斜率直线 -->
                    <line x1="${lineStart.x}" y1="${lineStart.y}" x2="${lineEnd.x}" y2="${lineEnd.y}" class="line" />

                    <!-- 点 A -->
                    <circle cx="${pointA.x}" cy="${pointA.y}" r="5" fill="blue" class="point" />
                    <text x="${pointA.x + 5}" y="${pointA.y - 5}" class="point-label">A(${xa},${ya})</text>

                    <!-- 点 B -->
                    <circle cx="${pointB.x}" cy="${pointB.y}" r="5" fill="red" class="point" />
                    <text x="${pointB.x + 5}" y="${pointB.y - 5}" class="point-label">B(${xb},${yb})</text>

                    ${xInterceptPoint ? `
                        <!-- x-intercept 点 -->
                        <circle cx="${xInterceptPoint.x}" cy="${xInterceptPoint.y}" r="5" fill="green" class="point" />
                        <text x="${xInterceptPoint.x + 5}" y="${xInterceptPoint.y - 5}" class="point-label">X₀(${this.xIntercept.toFixed(2)},0)</text>
                    ` : ''}
                </svg>
            `;
        }

        function findLineIntersections(k, b) {
            const intersections = [];

            // 直线与 x = -10 的交点
            let y = k * (-10) + b;
            if (y >= -10 && y <= 10) {
                intersections.push({ x: -10, y: y });
            }

            // 直线与 x = 10 的交点
            y = k * 10 + b;
            if (y >= -10 && y <= 10) {
                intersections.push({ x: 10, y: y });
            }

            // 直线与 y = 10 的交点
            if (k !== 0) { // 避免除以零
                let x = (10 - b) / k;
                if (x >= -10 && x <= 10) {
                    intersections.push({ x: x, y: 10 });
                }

                // 直线与 y = -10 的交点
                x = (-10 - b) / k;
                if (x >= -10 && x <= 10) {
                    intersections.push({ x: x, y: -10 });
                }
            }

            // 移除重复交点
            const unique = [];
            const map = new Map();
            intersections.forEach(pt => {
                const key = `${pt.x.toFixed(5)},${pt.y.toFixed(5)}`; // 使用固定小数位防止浮点数问题
                if (!map.has(key)) {
                    map.set(key, true);
                    unique.push(pt);
                }
            });

            return unique.slice(0, 2); // 返回前两个唯一交点
        }

        // 主应用逻辑
        class App {
            constructor() {
                this.state = {
                    currentQuestionType: null,
                    questionInstance: null,
                    correctCount: 0,
                    incorrectCount: 0
                };

                // 绑定DOM元素
                this.questionElement = document.getElementById('question');
                this.renderedAnswerElement = document.getElementById('rendered-answer');
                this.answerInput = document.getElementById('answer');
                this.submitButton = document.querySelector('.submit-button');
                this.resultElement = document.getElementById('result');
                this.scoreElement = document.getElementById('score');
                this.historyElement = document.getElementById('history');
                this.typeButtons = document.querySelectorAll('.type-button');

                // 绑定事件
                this.bindEvents();

                // 自动选择并生成第一类题型
                this.initializeDefaultQuestionType();
            }

            bindEvents() {
                // 题型选择按钮
                this.typeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const type = button.getAttribute('data-type');
                        this.selectQuestionType(type);
                    });
                });

                // 提交按钮
                this.submitButton.addEventListener('click', () => this.checkAnswer());

                // 回车键提交
                this.answerInput.addEventListener('keyup', event => {
                    if (event.key === 'Enter') this.checkAnswer();
                });

                // 实时预览
                this.answerInput.addEventListener('input', () => this.updatePreview());
            }

            initializeDefaultQuestionType() {
                if (this.typeButtons.length > 0) {
                    const firstButton = this.typeButtons[0];
                    const type = firstButton.getAttribute('data-type');
                    this.selectQuestionType(type);

                    // 添加激活状态的样式
                    this.typeButtons.forEach(btn => btn.classList.remove('active'));
                    firstButton.classList.add('active');
                }
            }

            selectQuestionType(type) {
                if (this.state.currentQuestionType !== type) {
                    this.state.currentQuestionType = type;
                    this.state.questionInstance = createQuestionType(type);
                    this.newQuestion();

                    // 更新按钮的激活状态
                    this.typeButtons.forEach(btn => {
                        if (btn.getAttribute('data-type') === type) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
            }

            newQuestion() {
                const questionData = this.state.questionInstance.generateQuestion();
                this.renderQuestion();
                this.clearInput();
            }

            renderQuestion() {
                const questionText = this.state.questionInstance.getQuestionText();
                const svg = this.state.questionInstance.getSVG();
                this.questionElement.innerHTML = `${questionText}<div class="coordinate-system">${svg}</div>`;
                MathJax.typesetPromise([this.questionElement]).catch(console.error);
            }

            clearInput() {
                this.answerInput.value = '';
                this.resultElement.textContent = '';
                this.resultElement.className = '';
                this.updateRenderedAnswer('');
            }

            updateRenderedAnswer(content) {
                if (content) {
                    this.renderedAnswerElement.innerHTML = `\\(${content}\\)`;
                } else {
                    this.renderedAnswerElement.innerHTML = '\\(\\text{您的答案将实时渲染在此处}\\)';
                }
                MathJax.typesetPromise([this.renderedAnswerElement]).catch(console.error);
            }

            updatePreview() {
                const input = this.answerInput.value;
                this.updateRenderedAnswer(input);
            }

            checkAnswer() {
                const userAnswer = toHalfWidth(this.answerInput.value.trim());
                if (!userAnswer) {
                    this.showResult('请输入答案！', false);
                    return;
                }

                const isCorrect = this.state.questionInstance.checkAnswer(userAnswer);

                if (isCorrect) {
                    this.showResult('正确!', true);
                    this.state.correctCount++;
                } else {
                    const correctAnswers = this.state.questionInstance.correctAnswer.join(' 或 ');
                    this.showResult(`错误。正确答案是: ${correctAnswers}`, false);
                    this.state.incorrectCount++;
                }

                this.updateScore();
                this.updateHistory(isCorrect);
                this.newQuestion();
            }

            showResult(message, isCorrect) {
                this.resultElement.textContent = message;
                this.resultElement.className = isCorrect ? 'correct' : 'incorrect';
            }

            updateScore() {
                this.scoreElement.textContent = `正确: ${this.state.correctCount} | 错误: ${this.state.incorrectCount}`;
            }

            updateHistory(isCorrect) {
                const row = document.createElement('div');
                row.classList.add('history-row', isCorrect ? 'correct' : 'incorrect');

                const questionClone = this.questionElement.cloneNode(true);

                // 给 SVG 添加类以便在历史记录中缩小
                const svg = questionClone.querySelector('svg');
                if (svg) {
                    svg.classList.add('history-svg');
                    svg.removeAttribute('width');
                    svg.removeAttribute('height');
                }

                const userAnswer = `\\(${this.answerInput.value}\\)`;
                const correctAnswer = `\\(${this.state.questionInstance.correctAnswer.join('\\) 或 \\(')}\\)`;
                const resultText = isCorrect ? '正确' : '错误';

                row.innerHTML = `
                    <div>${questionClone.innerHTML}</div>
                    <div>${userAnswer}</div>
                    <div>${correctAnswer}</div>
                    <div>${resultText}</div>
                `;
                this.historyElement.prepend(row);

                MathJax.typesetPromise([row]).catch(console.error);
            }
        }

        // 初始化应用
        document.addEventListener("DOMContentLoaded", () => {
            const app = new App();
        });
    </script>
</body>

</html>
