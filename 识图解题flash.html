<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>识图解题</title>
  <style>
    /* 引入谷歌字体 */
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');

    body {
      font-family: 'Noto Sans SC', sans-serif;
      margin: 0;
      background-color: #f0f2f5;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .left-pane {
      flex: 0 0 61.8%; /* 左侧占61.8% */
      min-width: 200px;
      background-color: #fff;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
      position: relative; /* 使隐藏粘贴区域可以定位 */
    }

    .chat-container {
      padding: 10px;
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100%;
      background-color: #fff;
    }

    .canvas-container {
      flex: 1;
      border: 1px solid #ccc;
      position: relative;
    }

    #drawingCanvas {
      width: 100%;
      height: 100%;
      touch-action: none; /* 防止触控设备的默认行为 */
      border-radius: 5px;
      display: block; /* 确保canvas为块级元素，避免行内元素的间隙问题 */
    }

    /* 隐藏的粘贴区域样式 */
    #hiddenPasteArea {
      opacity: 0;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .canvas-buttons {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap; /* 允许按钮换行，适应不同屏幕尺寸 */
    }

    .canvas-buttons button {
      flex: 1 1 20%; /* 每个按钮至少占20%的宽度 */
      padding: 10px;
      margin: 5px 2.5%;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-sizing: border-box;
    }

    .canvas-buttons button#pasteCanvasBtn {
      background-color: #FF9800; /* 橙色，区分其他按钮 */
    }

    .canvas-buttons button#pasteCanvasBtn:hover {
      background-color: #FB8C00;
    }

    .canvas-buttons button#copyCanvasBtn {
      background-color: #2196F3; /* 蓝色 */
    }

    .canvas-buttons button#copyCanvasBtn:hover {
      background-color: #1976D2;
    }

    .canvas-buttons button#sendCanvasBtn {
      background-color: #2196F3; /* 蓝色 */
    }

    .canvas-buttons button#sendCanvasBtn:hover {
      background-color: #5E35B1;
    }

    .canvas-buttons button#eraserBtn.active {
      background-color: #FF5722; /* 橙色 */
    }

    .canvas-buttons button:last-child {
      background-color: #f44336;
    }

    h2 {
      text-align: center;
      padding: 5px 0;
      margin: 0;
      background-color: #A5D6A7;
      color: #fff;
      font-weight: 700;
      width: 100%;
      box-sizing: border-box;
      border-radius: 5px;
    }

    .chat-box {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .message {
      margin: 20px 0; /* 增加消息之间的间距 */
      padding: 15px;
      border-radius: 10px;
      line-height: 1.6;
      max-width: 80%;
      word-wrap: break-word;
      position: relative;
    }

    .assistant {
      background-color: #e8f5e9;
      align-self: flex-start;
    }
    .user {
      background-color: #bbdefb;
      align-self: flex-end;
    }
    .timestamp {
      font-size: 12px;
      color: #999;
      position: absolute;
      bottom: -18px;
      right: 10px;
    }
    .input-area {
      display: flex;
      padding: 10px;
      background-color: #fff;
      box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
    }
    .text-input {
      flex: 1;
      min-height: 50px;
      max-height: 150px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #fafafa;
      overflow-y: auto;
      resize: none;
    }
    #sendBtn {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-left: 10px;
    }
    #sendBtn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .button-group {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background-color: #f0f2f5;
      flex-wrap: wrap; /* 允许按钮换行 */
    }
    .button-group button {
      flex: 1 1 30%; /* 每个按钮至少占30%的宽度 */
      padding: 10px 0;
      margin: 5px 1.6667%;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-sizing: border-box;
    }
    .button-group button:first-child {
      margin-left: 0;
    }
    .button-group button:last-child {
      margin-right: 0;
    }
    #clearBtn {
      background-color: #f44336;
    }

    /* 新增样式：复制按钮 */
    .copy-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 5px 8px;
      cursor: pointer;
      font-size: 12px;
      display: none; /* 默认隐藏，显示在需要的地方 */
    }

    .copy-button:hover {
      background-color: #1976D2;
    }

    /* 通知样式 */
    .notification {
      position: fixed;
      top: 20px; /* 从顶部开始 */
      left: 50%; /* 水平居中 */
      transform: translateX(-50%); /* 进一步确保水平居中 */
      background-color: #323232;
      color: #fff;
      padding: 15px 20px;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
      z-index: 1000;
    }

    .notification.show {
      opacity: 1;
      visibility: visible;
    }

    /* 可选：不同类型的通知 */
    .notification.success {
      background-color: #4CAF50; /* 绿色 */
    }

    .notification.error {
      background-color: #f44336; /* 红色 */
    }

  </style>

  <!-- MathJax for rendering LaTeX -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>

  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
</head>
<body>
  <div class="main-container">
    <!-- 左侧画布区域 -->
    <div class="left-pane">
      <h2>画布</h2>
      <div class="canvas-container">
        <!-- 添加 tabindex="0" 使画布可聚焦 -->
        <canvas id="drawingCanvas" tabindex="0"></canvas>
        <!-- 隐藏的 contenteditable 元素用于捕获粘贴事件 -->
        <div id="hiddenPasteArea" contenteditable="true"></div>
      </div>
      <div class="canvas-buttons">
        <button id="clearCanvasBtn">清除</button>
        <button id="copyCanvasBtn" class="copy-btn">复制</button>
        <button id="pasteCanvasBtn">粘贴</button>
        <button id="eraserBtn">擦写</button> <!-- 新增橡皮按钮 -->
        <button id="sendCanvasBtn">发送</button>
      </div>
    </div>

    <!-- 右侧聊天区域 -->
    <div class="chat-container">
      <h2>识图解题</h2>
      <div class="chat-box" id="chatBox">
        <div class="message assistant">
          <strong>玖数：</strong>您好！请在下方输入文字或粘贴图片进行对话。
          <div class="timestamp" style="display: none;"></div>
        </div>
      </div>
      <div class="input-area">
        <div class="text-input" id="textInput" contenteditable="true" placeholder="输入文字或粘贴图片..."></div>
        <button id="sendBtn" onclick="sendMessage()" disabled>发送</button>
      </div>
      <div class="button-group">
        <button id="uploadImageBtn">上传图片</button>
        <button id="captureImageBtn">拍照上传</button>
        <button id="clearBtn" onclick="clearChat()">清除对话</button>
      </div>
      <input type="file" id="uploadImageInput" accept="image/*" style="display:none;">
      <input type="file" id="captureImageInput" accept="image/*" capture="camera" style="display:none;">
    </div>
  </div>

  <!-- 通知元素 -->
  <div id="notification" class="notification"></div>

  <script>
    // 获取元素
    const chatBox = document.getElementById('chatBox');
    const textInput = document.getElementById('textInput');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const hiddenPasteArea = document.getElementById('hiddenPasteArea'); // 获取隐藏的粘贴区域
    const sendBtn = document.getElementById('sendBtn');
    const copyCanvasBtn = document.getElementById('copyCanvasBtn');
    const pasteCanvasBtn = document.getElementById('pasteCanvasBtn');
    const clearCanvasBtn = document.getElementById('clearCanvasBtn');
    const sendCanvasBtn = document.getElementById('sendCanvasBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const uploadImageBtn = document.getElementById('uploadImageBtn');
    const uploadImageInput = document.getElementById('uploadImageInput');
    const captureImageBtn = document.getElementById('captureImageBtn');
    const captureImageInput = document.getElementById('captureImageInput');
    const notification = document.getElementById('notification');

    let imageBase64 = '';
    let conversation = []; // 用于存储对话历史

    // 橡皮模式状态变量
    let isEraser = false;

    // 获取画布上下文
    const ctx = drawingCanvas.getContext('2d');
    let drawing = false;
    let lastX = 0;
    let lastY = 0;


    // 初始化画布
    function initializeCanvas() {
      // 填充白色背景
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

      // 设置绘图参数
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#000000';
    }

    initializeCanvas();

    // 辅助函数：自动缩放并居中绘制图像
    function drawImageScaled(img) {
      const canvasWidth = drawingCanvas.width;
      const canvasHeight = drawingCanvas.height;
      const imgWidth = img.width;
      const imgHeight = img.height;
      
      // 计算缩放比例，确保图像适应画布
      const scale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight, 1);
      
      const x = (canvasWidth - imgWidth * scale) / 2;
      const y = (canvasHeight - imgHeight * scale) / 20;
      
      ctx.drawImage(img, x, y, imgWidth * scale, imgHeight * scale);
    }

    // 绘图开始
    function startDrawing(x, y) {
      drawing = true;
      [lastX, lastY] = [x, y];
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
    }

    // 绘图结束
    function stopDrawing() {
      drawing = false;
    }
    // 定义线条宽度的最小值和最大值
    const MIN_LINE_WIDTH = 0.5;
    const MAX_LINE_WIDTH = 16;

    // 绘图过程
    function draw(x, y, pressure = 1) {
      if (!drawing) return;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = isEraser ? '#ffffff' : '#000000';
      ctx.lineWidth = isEraser ? 10 : (pressure > 0 ? Math.min(MAX_LINE_WIDTH, Math.max(MIN_LINE_WIDTH, pressure * MAX_LINE_WIDTH)) : 2);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      [lastX, lastY] = [x, y];
    }

    // 事件监听器

    // 鼠标事件
    drawingCanvas.addEventListener('mousedown', (e) => {
      startDrawing(e.offsetX, e.offsetY);
    });

    drawingCanvas.addEventListener('mousemove', (e) => {
      draw(e.offsetX, e.offsetY);
    });

    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);

    // 触摸事件
    drawingCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = drawingCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      startDrawing(x, y);
    });

    drawingCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = drawingCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      draw(x, y, touch.force || 1);
    });

    drawingCanvas.addEventListener('touchend', stopDrawing);
    drawingCanvas.addEventListener('touchcancel', stopDrawing);

    // Pointer事件
    drawingCanvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
        e.preventDefault();
        startDrawing(e.offsetX, e.offsetY);
        ctx.lineWidth = isEraser 
          ? Math.min(MAX_LINE_WIDTH, Math.max(MIN_LINE_WIDTH, Math.pow(e.pressure, 1.5) * MAX_LINE_WIDTH)) 
          : (e.pressure > 0 ? Math.min(MAX_LINE_WIDTH, Math.max(MIN_LINE_WIDTH, e.pressure * MAX_LINE_WIDTH)) : 2);
      }
    });

    drawingCanvas.addEventListener('pointermove', (e) => {
      if (!drawing) return;
      e.preventDefault();
      draw(e.offsetX, e.offsetY, e.pressure);
    });

    drawingCanvas.addEventListener('pointerup', stopDrawing);
    drawingCanvas.addEventListener('pointerout', stopDrawing);
    drawingCanvas.addEventListener('pointercancel', stopDrawing);

    // 橡皮按钮事件
    eraserBtn.addEventListener('click', () => {
      isEraser = !isEraser; // 切换橡皮模式状态

      if (isEraser) {
        ctx.strokeStyle = '#ffffff'; // 设置为白色以模拟橡皮擦效果
        drawingCanvas.style.cursor = 'not-allowed'; // 更改光标样式以指示橡皮模式
        showNotification('橡皮模式已启用。');
        eraserBtn.classList.add('active'); // 添加激活类
      } else {
        ctx.strokeStyle = '#000000'; // 恢复为默认绘图颜色
        drawingCanvas.style.cursor = 'default'; // 恢复默认光标
        showNotification('绘图模式已启用。');
        eraserBtn.classList.remove('active'); // 移除激活类
      }
    });

    // 清除画布按钮
    clearCanvasBtn.addEventListener('click', () => {
      ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      // 重新填充白色背景
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      showNotification('画布已清除。');
    });

    // 画布复制功能
    copyCanvasBtn.addEventListener('click', async () => {
      try {
        // 将画布转换为Blob
        const blob = await new Promise(resolve => drawingCanvas.toBlob(resolve, 'image/png'));
        if (!blob) {
          showNotification('无法复制画布内容。', 'error');
          return;
        }

        // 使用Clipboard API复制图片
        const data = [new ClipboardItem({ 'image/png': blob })];
        await navigator.clipboard.write(data);
        showNotification('画布内容已复制到剪贴板。');
      } catch (err) {
        console.error('复制失败:', err);
        showNotification('复制失败，请确保浏览器支持此功能并授予相关权限。', 'error');
      }
    });

    // 发送画布内容按钮
    sendCanvasBtn.addEventListener('click', () => {
      drawingCanvas.toBlob((blob) => {
        const reader = new FileReader();
        reader.onloadend = function() {
          const base64data = reader.result.split(',')[1];
          sendImageMessage(base64data);
        };
        reader.readAsDataURL(blob);
      });
    });

    // 发送图片消息
    async function sendImageMessage(base64Image) {
      const userMessage = document.createElement('div');
      userMessage.className = 'message user';
      const img = document.createElement('img');
      img.src = 'data:image/png;base64,' + base64Image;
      img.style.maxWidth = '100%';
      img.style.maxHeight = '200px';
      userMessage.innerHTML = '<strong>我：</strong> ';
      userMessage.appendChild(img);

      // 添加时间戳
      const userTimestamp = document.createElement('div');
      userTimestamp.className = 'timestamp';
      userTimestamp.textContent = getCurrentTime();
      userMessage.appendChild(userTimestamp);

      chatBox.appendChild(userMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      const assistantMessage = document.createElement('div');
      assistantMessage.className = 'message assistant';
      assistantMessage.innerHTML = '<strong>玖数：</strong> 思考中，请稍等...';

      chatBox.appendChild(assistantMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      // 构建消息内容，包含图像和必要的提示语
      const prompt = "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默温柔阳光有诗意。";

      const messages = [
        { type: "image_url", image_url: { url: base64Image } },
        { type: "text", text: prompt }
      ];

      // 将用户消息添加到对话历史
      conversation.push({
        role: "user",
        content: messages
      });

      // 如果对话历史超过10条（5轮对话），删除最早的消息
      if (conversation.length > 10) {
        conversation = conversation.slice(conversation.length - 10);
      }

      try {
        const response = await fetch('https://open.bigmodel.cn/api/paas/v4/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            // 请替换为您的API密钥，切勿将密钥暴露在客户端代码中
            'Authorization': 'Bearer 046acb99c5a6dd6680049c766c8b454b.Jc1U4euX045uExXU'
          },
          body: JSON.stringify({
            model: "glm-4v-flash",
            messages: conversation
          })
        });

        const result = await response.json();
        if (result.choices && result.choices[0] && result.choices[0].message) {
          const content = result.choices[0].message.content;

          // 将助手的回复添加到对话历史
          conversation.push({
            role: "assistant",
            content: content
          });

          // 同样限制对话历史的长度
          if (conversation.length > 10) {
            conversation = conversation.slice(conversation.length - 10);
          }

          assistantMessage.innerHTML = '<strong>玖数：</strong> ';
          typeWriter(assistantMessage, parseContent(content));

          MathJax.typesetPromise().then(() => {
            document.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
          });

          // 添加时间戳
          const timestamp = document.createElement('div');
          timestamp.className = 'timestamp';
          timestamp.textContent = getCurrentTime();
          assistantMessage.appendChild(timestamp);

          chatBox.scrollTop = chatBox.scrollHeight;

        } else {
          assistantMessage.innerHTML = '<strong>玖数：</strong> 未能生成有效的回复内容。';
        }

      } catch (error) {
        console.error("请求出错：", error);
        assistantMessage.innerHTML = '<strong>玖数：</strong> 出错了，请稍后再试。';
      }

      imageBase64 = ''; // 清空图片数据
    }

    // 发送文字消息
    async function sendMessage() {
      const userMessage = document.createElement('div');
      userMessage.className = 'message user';
      userMessage.innerHTML = '<strong>我：</strong> ' + textInput.innerHTML;

      // 添加时间戳
      const userTimestamp = document.createElement('div');
      userTimestamp.className = 'timestamp';
      userTimestamp.textContent = getCurrentTime();
      userMessage.appendChild(userTimestamp);

      chatBox.appendChild(userMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      const assistantMessage = document.createElement('div');
      assistantMessage.className = 'message assistant';
      assistantMessage.innerHTML = '<strong>玖数：</strong> 思考中，请稍等...';

      chatBox.appendChild(assistantMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      // 获取输入内容
      let textContent = textInput.innerText.trim();
      textInput.innerHTML = '';
      updateSendButton();

      // 如果没有文本输入，且有图片，则自动添加提示文字
      if (!textContent && imageBase64) {
        textContent = "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默温柔阳光有诗意。";
      }

      if (textContent && !imageBase64) {
        textContent += "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默温柔阳光有诗意。";
      }

      // 构建消息内容
      const messages = [];
      if (textContent) {
        messages.push({ type: "text", text: textContent });
      }
      if (imageBase64) {
        messages.push({ type: "image_url", image_url: { url: imageBase64 } });
      }

      // 确保至少有一条消息内容
      if (messages.length === 0) {
        assistantMessage.innerHTML = '<strong>玖数：</strong> 请输入文字或粘贴图片后再发送。';
        return;
      }

      // 将用户消息添加到对话历史
      conversation.push({
        role: "user",
        content: messages
      });

      // 如果对话历史超过10条（5轮对话），删除最早的消息
      if (conversation.length > 10) {
        conversation = conversation.slice(conversation.length - 10);
      }

      try {
        const response = await fetch('https://open.bigmodel.cn/api/paas/v4/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            // 请替换为您的API密钥，切勿将密钥暴露在客户端代码中
            'Authorization': 'Bearer 046acb99c5a6dd6680049c766c8b454b.Jc1U4euX045uExXU'
          },
          body: JSON.stringify({
            model: "glm-4v-flash",
            messages: conversation
          })
        });

        const result = await response.json();
        if (result.choices && result.choices[0] && result.choices[0].message) {
          const content = result.choices[0].message.content;

          // 将助手的回复添加到对话历史
          conversation.push({
            role: "assistant",
            content: content
          });

          // 同样限制对话历史的长度
          if (conversation.length > 10) {
            conversation = conversation.slice(conversation.length - 10);
          }

          assistantMessage.innerHTML = '<strong>玖数：</strong> ';
          typeWriter(assistantMessage, parseContent(content));

          MathJax.typesetPromise().then(() => {
            document.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
          });

          // 添加时间戳
          const timestamp = document.createElement('div');
          timestamp.className = 'timestamp';
          timestamp.textContent = getCurrentTime();
          assistantMessage.appendChild(timestamp);

          chatBox.scrollTop = chatBox.scrollHeight;

        } else {
          assistantMessage.innerHTML = '<strong>玖数：</strong> 未能生成有效的回复内容。';
        }

      } catch (error) {
        console.error("请求出错：", error);
        assistantMessage.innerHTML = '<strong>玖数：</strong> 出错了，请稍后再试。';
      }

      imageBase64 = ''; // 清空图片数据
    }

    // 处理隐藏粘贴区域的粘贴事件
    hiddenPasteArea.addEventListener('paste', (event) => {
      console.log('画布粘贴事件触发');
      const items = event.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf("image") !== -1) {
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
              // 清除画布并填充白色背景
              ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
              
              // 绘制缩放后的图像
              drawImageScaled(img);
              showNotification('图片已粘贴并居中显示在画布上。');
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(blob);
          event.preventDefault();
        } else if (item.type === "text/plain") {
          item.getAsString((text) => {
            // 设置字体样式
            ctx.font = "20px 'Noto Sans SC', sans-serif";
            ctx.fillStyle = "#000";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // 计算居中位置
            const canvasWidth = drawingCanvas.width;
            const canvasHeight = drawingCanvas.height;

            // 清除画布当前内容
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            // 重新填充白色背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // 绘制文本
            wrapText(ctx, text, canvasWidth / 2, canvasHeight / 2, canvasWidth - 40, 25);
            showNotification('文本已粘贴并居中显示在画布上。');
          });
          event.preventDefault();
        }
      }
    });

    // 辅助函数：自动换行绘制文本
    function wrapText(context, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let lines = [];
      
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          lines.push(line);
          line = words[n] + ' ';
        }
        else {
          line = testLine;
        }
      }
      lines.push(line);

      // 计算文本总高度
      const totalHeight = lines.length * lineHeight;
      let startY = y - totalHeight / 2 + lineHeight / 2;

      for(let i = 0; i < lines.length; i++) {
        context.fillText(lines[i], x, startY + (i * lineHeight));
      }
    }

    // 显示通知的函数
    function showNotification(message, type = 'success') {
      notification.textContent = message;
      notification.className = `notification show ${type}`;

      // 2秒后隐藏通知
      setTimeout(() => {
        notification.classList.remove('show', type);
      }, 2000);
    }

    // 动态检测是否可以发送消息
    function updateSendButton() {
      const textContent = textInput.innerText.trim();
      sendBtn.disabled = textContent === '' && !imageBase64;
    }

    textInput.addEventListener('input', updateSendButton);

    // 处理粘贴事件到聊天输入框
    textInput.addEventListener('paste', (event) => {
      const items = event.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf("image") !== -1) {
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = document.createElement('img');
            img.src = e.target.result;
            img.style.maxWidth = '100%';
            img.style.maxHeight = '200px';
            textInput.appendChild(img);
            imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
            updateSendButton();  // 启用发送按钮
          };
          reader.readAsDataURL(blob);
          event.preventDefault();
        }
      }
    });

    // 处理上传本地图片按钮点击事件
    uploadImageBtn.addEventListener('click', () => {
      uploadImageInput.click();
    });

    uploadImageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '200px';
          textInput.appendChild(img);
          imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
          updateSendButton();  // 启用发送按钮
        };
        reader.readAsDataURL(file);
      }
    });

    // 处理拍照上传按钮点击事件
    captureImageBtn.addEventListener('click', () => {
      captureImageInput.click();
    });

    captureImageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '200px';
          textInput.appendChild(img);
          imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
          updateSendButton();  // 启用发送按钮
        };
        reader.readAsDataURL(file);
      }
    });

    // 当用户点击画布时，聚焦隐藏的粘贴区域
    drawingCanvas.addEventListener('click', () => {
      hiddenPasteArea.focus();
    });

    // 添加粘贴按钮的点击事件监听器
    pasteCanvasBtn.addEventListener('click', async () => {
      try {
        // 检查浏览器是否支持 Clipboard API
        if (!navigator.clipboard) {
          showNotification('当前浏览器不支持剪贴板操作。', 'error');
          return;
        }

        // 请求剪贴板权限
        const permissionStatus = await navigator.permissions.query({ name: 'clipboard-read' });
        if (permissionStatus.state === 'denied') {
          showNotification('无法访问剪贴板，请检查权限设置。', 'error');
          return;
        }

        // 读取剪贴板内容
        const clipboardItems = await navigator.clipboard.read();

        for (const item of clipboardItems) {
          if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
            const blob = await item.getType('image/png');
            const reader = new FileReader();
            reader.onload = function(e) {
              const img = new Image();
              img.onload = function() {
                // 清除画布并填充白色背景
                ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                
                // 绘制缩放后的图像
                drawImageScaled(img);
                showNotification('图片已粘贴并居中显示在画布上。');
              };
              img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
            return; // 处理完图像后退出
          } else if (item.types.includes('text/plain')) {
            const text = await navigator.clipboard.readText();
            if (text) {
              // 设置字体样式
              ctx.font = "20px 'Noto Sans SC', sans-serif";
              ctx.fillStyle = "#000";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";

              // 计算居中位置
              const canvasWidth = drawingCanvas.width;
              const canvasHeight = drawingCanvas.height;

              // 清除画布当前内容
              ctx.clearRect(0, 0, canvasWidth, canvasHeight);
              // 重新填充白色背景
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(0, 0, canvasWidth, canvasHeight);

              // 绘制文本
              wrapText(ctx, text, canvasWidth / 2, canvasHeight / 2, canvasWidth - 40, 25);
              showNotification('文本已粘贴并居中显示在画布上。');
            }
            return; // 处理完文本后退出
          }
        }

        showNotification('剪贴板中没有可粘贴的内容。', 'error');
      } catch (err) {
        console.error('粘贴失败:', err);
        showNotification('粘贴失败，请确保浏览器支持此功能并授予相关权限。', 'error');
      }
    });

    // 显示和发送消息的函数
    async function sendMessage() {
      const userMessage = document.createElement('div');
      userMessage.className = 'message user';
      userMessage.innerHTML = '<strong>我：</strong> ' + textInput.innerHTML;

      // 添加时间戳
      const userTimestamp = document.createElement('div');
      userTimestamp.className = 'timestamp';
      userTimestamp.textContent = getCurrentTime();
      userMessage.appendChild(userTimestamp);

      chatBox.appendChild(userMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      const assistantMessage = document.createElement('div');
      assistantMessage.className = 'message assistant';
      assistantMessage.innerHTML = '<strong>玖数：</strong> 思考中，请稍等...';

      chatBox.appendChild(assistantMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      // 获取输入内容
      let textContent = textInput.innerText.trim();
      textInput.innerHTML = '';
      updateSendButton();

      // 如果没有文本输入，且有图片，则自动添加提示文字
      if (!textContent && imageBase64) {
        textContent = "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默。你要强调，记公式本身没意义，推导的过程才能关联所有的本质。最后给出总结，及今后学习的方向。";
      }

      if (textContent && !imageBase64) {
        textContent += "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默。你要强调，记公式本身没意义，推导的过程才能关联所有的本质。最后给出总结，及今后学习的方向。";
      }

      // 构建消息内容
      const messages = [];
      if (textContent) {
        messages.push({ type: "text", text: textContent });
      }
      if (imageBase64) {
        messages.push({ type: "image_url", image_url: { url: imageBase64 } });
      }

      // 确保至少有一条消息内容
      if (messages.length === 0) {
        assistantMessage.innerHTML = '<strong>玖数：</strong> 请输入文字或粘贴图片后再发送。';
        return;
      }

      // 将用户消息添加到对话历史
      conversation.push({
        role: "user",
        content: messages
      });

      // 如果对话历史超过10条（5轮对话），删除最早的消息
      if (conversation.length > 10) {
        conversation = conversation.slice(conversation.length - 10);
      }

      try {
        const response = await fetch('https://open.bigmodel.cn/api/paas/v4/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            // 请替换为您的API密钥，切勿将密钥暴露在客户端代码中
            'Authorization': 'Bearer 046acb99c5a6dd6680049c766c8b454b.Jc1U4euX045uExXU'
          },
          body: JSON.stringify({
            model: "glm-4v-flash",
            messages: conversation
          })
        });

        const result = await response.json();
        if (result.choices && result.choices[0] && result.choices[0].message) {
          const content = result.choices[0].message.content;

          // 将助手的回复添加到对话历史
          conversation.push({
            role: "assistant",
            content: content
          });

          // 同样限制对话历史的长度
          if (conversation.length > 10) {
            conversation = conversation.slice(conversation.length - 10);
          }

          assistantMessage.innerHTML = '<strong>玖数：</strong> ';
          typeWriter(assistantMessage, parseContent(content));

          MathJax.typesetPromise().then(() => {
            document.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
          });





          // 添加时间戳
          const timestamp = document.createElement('div');
          timestamp.className = 'timestamp';
          timestamp.textContent = getCurrentTime();
          assistantMessage.appendChild(timestamp);

          chatBox.scrollTop = chatBox.scrollHeight;

        } else {
          assistantMessage.innerHTML = '<strong>玖数：</strong> 未能生成有效的回复内容。';
        }

      } catch (error) {
        console.error("请求出错：", error);
        assistantMessage.innerHTML = '<strong>玖数：</strong> 出错了，请稍后再试。';
      }

      imageBase64 = ''; // 清空图片数据
    }

    // 处理粘贴到聊天输入框的图片
    textInput.addEventListener('paste', (event) => {
      const items = event.clipboardData.items;
      for (let item of items) {
        if (item.type.indexOf("image") !== -1) {
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = document.createElement('img');
            img.src = e.target.result;
            img.style.maxWidth = '100%';
            img.style.maxHeight = '200px';
            textInput.appendChild(img);
            imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
            updateSendButton();  // 启用发送按钮
          };
          reader.readAsDataURL(blob);
          event.preventDefault();
        }
      }
    });

    // 处理上传本地图片按钮点击事件
    uploadImageBtn.addEventListener('click', () => {
      uploadImageInput.click();
    });

    uploadImageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '200px';
          textInput.appendChild(img);
          imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
          updateSendButton();  // 启用发送按钮
        };
        reader.readAsDataURL(file);
      }
    });

    // 处理拍照上传按钮点击事件
    captureImageBtn.addEventListener('click', () => {
      captureImageInput.click();
    });

    captureImageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '200px';
          textInput.appendChild(img);
          imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
          updateSendButton();  // 启用发送按钮
        };
        reader.readAsDataURL(file);
      }
    });

    // 当用户点击画布时，聚焦隐藏的粘贴区域
    drawingCanvas.addEventListener('click', () => {
      hiddenPasteArea.focus();
    });

    // 添加粘贴按钮的点击事件监听器
    pasteCanvasBtn.addEventListener('click', async () => {
      try {
        // 检查浏览器是否支持 Clipboard API
        if (!navigator.clipboard) {
          showNotification('当前浏览器不支持剪贴板操作。', 'error');
          return;
        }

        // 请求剪贴板权限
        const permissionStatus = await navigator.permissions.query({ name: 'clipboard-read' });
        if (permissionStatus.state === 'denied') {
          showNotification('无法访问剪贴板，请检查权限设置。', 'error');
          return;
        }

        // 读取剪贴板内容
        const clipboardItems = await navigator.clipboard.read();

        for (const item of clipboardItems) {
          if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
            const blob = await item.getType('image/png');
            const reader = new FileReader();
            reader.onload = function(e) {
              const img = new Image();
              img.onload = function() {
                // 清除画布并填充白色背景
                ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                
                // 绘制缩放后的图像
                drawImageScaled(img);
                showNotification('图片已粘贴并居中显示在画布上。');
              };
              img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
            return; // 处理完图像后退出
          } else if (item.types.includes('text/plain')) {
            const text = await navigator.clipboard.readText();
            if (text) {
              // 设置字体样式
              ctx.font = "20px 'Noto Sans SC', sans-serif";
              ctx.fillStyle = "#000";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";

              // 计算居中位置
              const canvasWidth = drawingCanvas.width;
              const canvasHeight = drawingCanvas.height;

              // 清除画布当前内容
              ctx.clearRect(0, 0, canvasWidth, canvasHeight);
              // 重新填充白色背景
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(0, 0, canvasWidth, canvasHeight);

              // 绘制文本
              wrapText(ctx, text, canvasWidth / 2, canvasHeight / 2, canvasWidth - 40, 25);
              showNotification('文本已粘贴并居中显示在画布上。');
            }
            return; // 处理完文本后退出
          }
        }

        showNotification('剪贴板中没有可粘贴的内容。', 'error');
      } catch (err) {
        console.error('粘贴失败:', err);
        showNotification('粘贴失败，请确保浏览器支持此功能并授予相关权限。', 'error');
      }
    });






    // 辅助函数：自动换行绘制文本
    function wrapText(context, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let lines = [];
      
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          lines.push(line);
          line = words[n] + ' ';
        }
        else {
          line = testLine;
        }
      }
      lines.push(line);

      // 计算文本总高度
      const totalHeight = lines.length * lineHeight;
      let startY = y - totalHeight / 2 + lineHeight / 2;

      for(let i = 0; i < lines.length; i++) {
        context.fillText(lines[i], x, startY + (i * lineHeight));
      }
    }

    // 显示通知的函数
    function showNotification(message, type = 'success') {
      notification.textContent = message;
      notification.className = `notification show ${type}`;

      // 2秒后隐藏通知
      setTimeout(() => {
        notification.classList.remove('show', type);
      }, 2000);
    }

    // 动态检测是否可以发送消息
    function updateSendButton() {
      const textContent = textInput.innerText.trim();
      sendBtn.disabled = textContent === '' && !imageBase64;
    }

    textInput.addEventListener('input', updateSendButton);

    // 处理键盘事件
    textInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey) {
        event.preventDefault(); // 阻止默认的换行操作
        sendMessage();
      }
    });



    // 显示和发送消息的函数
    async function sendMessage() {
      const userMessage = document.createElement('div');
      userMessage.className = 'message user';
      userMessage.innerHTML = '<strong>我：</strong> ' + textInput.innerHTML;

      // 添加时间戳
      const userTimestamp = document.createElement('div');
      userTimestamp.className = 'timestamp';
      userTimestamp.textContent = getCurrentTime();
      userMessage.appendChild(userTimestamp);

      chatBox.appendChild(userMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      const assistantMessage = document.createElement('div');
      assistantMessage.className = 'message assistant';
      assistantMessage.innerHTML = '<strong>玖数：</strong> 思考中，请稍等...';

      chatBox.appendChild(assistantMessage);
      chatBox.scrollTop = chatBox.scrollHeight;

      // 获取输入内容
      let textContent = textInput.innerText.trim();
      textInput.innerHTML = '';
      updateSendButton();

      // 如果没有文本输入，且有图片，则自动添加提示文字
      if (!textContent && imageBase64) {
        textContent = "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默。你要强调，记公式本身没意义，推导的过程才能关联所有的本质。最后给出总结，及今后学习的方向。";
      }

      if (textContent && !imageBase64) {
        textContent += "请直接以教师的语气回答学生的问题，避免使用客套语气。你是一个有着20多年经验的数学物理竞赛教练。任务：解读内容；如果是解题过程，就一步步点评分析；如果是题目，就给出尽可能多的解答方法，风格：幽默。你要强调，记公式本身没意义，推导的过程才能关联所有的本质。最后给出总结，及今后学习的方向。";
      }

      // 构建消息内容
      const messages = [];
      if (textContent) {
        messages.push({ type: "text", text: textContent });
      }
      if (imageBase64) {
        messages.push({ type: "image_url", image_url: { url: imageBase64 } });
      }

      // 确保至少有一条消息内容
      if (messages.length === 0) {
        assistantMessage.innerHTML = '<strong>玖数：</strong> 请输入文字或粘贴图片后再发送。';
        return;
      }

      // 将用户消息添加到对话历史
      conversation.push({
        role: "user",
        content: messages
      });

      // 如果对话历史超过10条（5轮对话），删除最早的消息
      if (conversation.length > 10) {
        conversation = conversation.slice(conversation.length - 10);
      }

      try {
        const response = await fetch('https://open.bigmodel.cn/api/paas/v4/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            // 请替换为您的API密钥，切勿将密钥暴露在客户端代码中
            'Authorization': 'Bearer 046acb99c5a6dd6680049c766c8b454b.Jc1U4euX045uExXU'
          },
          body: JSON.stringify({
            model: "glm-4v-flash",
            messages: conversation
          })
        });

        const result = await response.json();
        if (result.choices && result.choices[0] && result.choices[0].message) {
          const content = result.choices[0].message.content;

          // 将助手的回复添加到对话历史
          conversation.push({
            role: "assistant",
            content: content
          });

          // 同样限制对话历史的长度
          if (conversation.length > 10) {
            conversation = conversation.slice(conversation.length - 10);
          }

          assistantMessage.innerHTML = '<strong>玖数：</strong> ';
          typeWriter(assistantMessage, parseContent(content));

          MathJax.typesetPromise().then(() => {
            document.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
          });

          // 添加时间戳
          const timestamp = document.createElement('div');
          timestamp.className = 'timestamp';
          timestamp.textContent = getCurrentTime();
          assistantMessage.appendChild(timestamp);

          chatBox.scrollTop = chatBox.scrollHeight;

        } else {
          assistantMessage.innerHTML = '<strong>玖数：</strong> 未能生成有效的回复内容。';
        }

      } catch (error) {
        console.error("请求出错：", error);
        assistantMessage.innerHTML = '<strong>玖数：</strong> 出错了，请稍后再试。';
      }

      imageBase64 = ''; // 清空图片数据
    }

    // 处理上传图片按钮点击事件
    uploadImageBtn.addEventListener('click', () => {
      uploadImageInput.click();
    });

    uploadImageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '200px';
          textInput.appendChild(img);
          imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
          updateSendButton();  // 启用发送按钮
        };
        reader.readAsDataURL(file);
      }
    });

    // 处理拍照上传按钮点击事件
    captureImageBtn.addEventListener('click', () => {
      captureImageInput.click();
    });

    captureImageInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '200px';
          textInput.appendChild(img);
          imageBase64 = e.target.result.split(',')[1];  // 去掉base64前缀
          updateSendButton();  // 启用发送按钮
        };
        reader.readAsDataURL(file);
      }
    });

    // 显示复制按钮功能
    function initializeCopyButtons() {
      const copyButtons = document.querySelectorAll('.copy-button');
      copyButtons.forEach(button => {
        button.style.display = 'inline-block'; // 显示复制按钮
        button.addEventListener('click', () => {
          const textToCopy = button.getAttribute('data-clipboard-text');
          if (!textToCopy) return;

          navigator.clipboard.writeText(textToCopy).then(() => {
            showNotification('LaTeX 代码已复制到剪贴板。');
          }).catch(err => {
            console.error('复制失败:', err);
            showNotification('复制失败，请确保浏览器支持此功能并授予相关权限。', 'error');
          });
        });
      });
    }

    // 解析内容，添加复制按钮
    function parseContent(content) {
      // 将数学公式和代码块转换为HTML，并添加复制按钮
      let parsedContent = content
        // 处理块级数学公式
        .replace(/\$\$(.*?)\$\$/gs, (match, p1) => {
          return `<div class="math-block">
                    <span class="math">\\[${p1}\\]</span>
                    <button class="copy-button" data-clipboard-text="\\[${p1}\\]">复制</button>
                  </div>`;
        })
        // 处理行内数学公式
        .replace(/\$(.*?)\$/g, (match, p1) => {
          return `<span class="math-inline">
                    <span class="math">\\(${p1}\\)</span>
                    <button class="copy-button" data-clipboard-text="\\(${p1}\\)">复制</button>
                  </span>`;
        })
        // 处理代码块
        .replace(/```([\s\S]*?)```/g, (match, p1) => {
          return `<pre><code>${p1}</code></pre>`;
        });
      return parsedContent;
    }

    // 打字机效果
    function typeWriter(element, htmlContent) {
      let i = 0;
      let isTag = false;
      let text = element.innerHTML; // 包含<strong>玖数：</strong>

      function type() {
        if (i < htmlContent.length) {
          let currentChar = htmlContent.charAt(i);

          if (currentChar === '<') {
            isTag = true;
          }
          if (currentChar === '>') {
            isTag = false;
          }

          text += currentChar;
          element.innerHTML = text;
          i++;

          if (isTag) {
            type();
          } else {
            setTimeout(type, 1); // 调整打字速度
          }

          chatBox.scrollTop = chatBox.scrollHeight; // 保持滚动到底部
        } else {
          // 打字完成，渲染MathJax公式和代码高亮
          MathJax.typesetPromise().then(() => {
            document.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
            // 初始化复制按钮功能
            initializeCopyButtons();
          });
        }
      }

      type();
    }

    // 获取当前时间
    function getCurrentTime() {
      const now = new Date();
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      return `${hours}:${minutes}`;
    }

    // 清除聊天记录
    function clearChat() {
      chatBox.innerHTML = '<div class="message assistant"><strong>玖数：</strong> 您好！请在下方输入文字或粘贴图片进行对话。</div>';
      conversation = []; // 重置对话历史
    }

    // 画布调整大小和响应式
    function resizeCanvas() {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = drawingCanvas.width;
      tempCanvas.height = drawingCanvas.height;
      tempCtx.drawImage(drawingCanvas, 0, 0);

      drawingCanvas.width = drawingCanvas.parentElement.clientWidth;
      drawingCanvas.height = drawingCanvas.parentElement.clientHeight;

      // 重新初始化画布
      initializeCanvas();

      // 重新绘制之前的内容
      ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, drawingCanvas.width, drawingCanvas.height);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>
